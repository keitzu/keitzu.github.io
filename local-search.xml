<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>经典排序算法总结</title>
    <link href="/2020/sorting-algorithm/"/>
    <url>/2020/sorting-algorithm/</url>
    
    <content type="html"><![CDATA[<p>排序算法是最基础的算法之一，可以使用的场景也很多。不同的排序算法有不同的优缺点，这里列举了八种常用的排序算法。<br><a id="more"></a><br>各个算法的复杂度和稳定性：</p><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(n^{\frac{3}{2}})$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(nlog_{2}n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(nlog_{2}n)$</td><td>$O(log_{2}n)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(nlog_{2}n)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>基数排序</td><td>$O(n*k)$</td><td>$O(n+k)$</td><td>稳定</td></tr></tbody></table></div><blockquote><p>本页面所有代码均使用C实现，使用<a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">Leetcode</a>的数组排序进行测试（题目：给你一个整数数组 nums，请你将该数组升序排列）,部分不够高效的排序算法在进行大量数据排序时会超出时间限制。部分排序算法参考<a href="https://leetcode-cn.com/problems/sort-an-array/solution/" target="_blank" rel="noopener">排序数组-题解</a></p></blockquote><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><h4 id="1-1、步骤"><a href="#1-1、步骤" class="headerlink" title="1.1、步骤"></a>1.1、步骤</h4><ol><li>从头开始比较相邻元素，如果大小顺序错误则交换位置</li><li>往后移动继续比较，直到末尾（这时最大的元素应在末尾）</li><li>如果某一趟排序未进行交换操作则排序结束</li><li>忽略末尾已排序的元素，重复进行1与2直到排序完成</li></ol><h4 id="1-2、实现"><a href="#1-2、实现" class="headerlink" title="1.2、实现"></a>1.2、实现</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize = numsSize;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">bool</span> isFinished = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; numsSize - i - <span class="hljs-number">1</span>; j++)&#123;            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j + <span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">int</span> temp = nums[j];                nums[j] = nums[j + <span class="hljs-number">1</span>];                nums[j + <span class="hljs-number">1</span>] = temp;                isFinished = <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(isFinished) <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><h4 id="2-1、步骤"><a href="#2-1、步骤" class="headerlink" title="2.1、步骤"></a>2.1、步骤</h4><ol><li>遍历数组找出其中的最小元素</li><li>将最小元素放置到已排序部分队尾</li><li>剩余元素重复1于2直至排序完成</li></ol><h4 id="2-2、实现"><a href="#2-2、实现" class="headerlink" title="2.2、实现"></a>2.2、实现</h4><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize = numsSize;    <span class="hljs-keyword">int</span> i, j, <span class="hljs-built_in">min</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;        <span class="hljs-built_in">min</span> = i;        <span class="hljs-keyword">for</span>(j = i; j &lt; numsSize; j++)&#123;            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[<span class="hljs-built_in">min</span>])&#123;                <span class="hljs-built_in">min</span> = j;            &#125;        &#125;        <span class="hljs-keyword">int</span> temp = nums[i];        nums[i] = nums[<span class="hljs-built_in">min</span>];        nums[<span class="hljs-built_in">min</span>] = temp;    &#125;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h3><h4 id="3-1、步骤"><a href="#3-1、步骤" class="headerlink" title="3.1、步骤"></a>3.1、步骤</h4><p>在要排序的一组数中，假定前n-1个数已经是有序序列</p><ol><li>找到第n个数插入有序序列的位置k</li><li>将k到n-1位的数后移一位，第k位的值赋值位第n位的值</li><li>重复1与2直到排序完成</li></ol><h4 id="3-2、实现"><a href="#3-2、实现" class="headerlink" title="3.2、实现"></a>3.2、实现</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize = numsSize;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; numsSize; i++)&#123;        <span class="hljs-keyword">int</span> temp = nums[i];        j = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>( j &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; nums[j])&#123;            nums[j + <span class="hljs-number">1</span>] = nums[j];            j--;        &#125;        nums[j + <span class="hljs-number">1</span>] = temp;    &#125;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h3><h4 id="4-1、步骤"><a href="#4-1、步骤" class="headerlink" title="4.1、步骤"></a>4.1、步骤</h4><ol><li>取一个小于n的步长$d_1$，将带待排序元素分为$d_1$组</li><li>对每一组分别进行插入排序</li><li>取第二个步长$d_2$($d_1$&gt;$d_2$),重复1与2直至排序完成</li></ol><h4 id="4-2、实现"><a href="#4-2、实现" class="headerlink" title="4.2、实现"></a>4.2、实现</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize = numsSize;    <span class="hljs-keyword">int</span> gap, i, j;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span> (gap = numsSize / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>)        <span class="hljs-keyword">for</span> (i = gap; i &lt; numsSize; i++) &#123;            temp = nums[i];            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; temp; j -= gap)                nums[j + gap] = nums[j];            nums[j + gap] = temp;        &#125;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="5、2路-归并排序"><a href="#5、2路-归并排序" class="headerlink" title="5、2路-归并排序"></a>5、2路-归并排序</h3><h4 id="5-1、步骤"><a href="#5-1、步骤" class="headerlink" title="5.1、步骤"></a>5.1、步骤</h4><p>假定待排序表中n个元素为n个有序的子表，归并是指将两个有序表合成为一个新的有序表</p><ol><li>将子表两两归并，得到n/2个长度为2或1的有序子表</li><li>重复1直至排序完成</li></ol><h4 id="5-2、实现"><a href="#5-2、实现" class="headerlink" title="5.2、实现"></a>5.2、实现</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> midIndex, <span class="hljs-keyword">int</span> endIndex, <span class="hljs-keyword">int</span>* sorted)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> left = startIndex;    <span class="hljs-keyword">int</span> right = midIndex + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> sortedIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt;= midIndex &amp;&amp; right &lt;= endIndex) &#123;        <span class="hljs-keyword">if</span> (nums[left] &lt; nums[right]) &#123;            sorted[sortedIndex++] = nums[left++];        &#125; <span class="hljs-keyword">else</span> &#123;            sorted[sortedIndex++] = nums[right++];        &#125;    &#125;    <span class="hljs-keyword">while</span> (left &lt;= midIndex) &#123;        sorted[sortedIndex++] = nums[left++];    &#125;    <span class="hljs-keyword">while</span> (right &lt;= endIndex) &#123;        sorted[sortedIndex++] = nums[right++];    &#125;    sortedIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (startIndex &lt;= endIndex) &#123;        nums[startIndex++] = sorted[sortedIndex++];    &#125;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> endIndex, <span class="hljs-keyword">int</span>* sorted)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (endIndex &lt;= startIndex) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> midIndex = (startIndex + endIndex) / <span class="hljs-number">2</span>;    MergeSort(nums, startIndex, midIndex, sorted);    MergeSort(nums, midIndex + <span class="hljs-number">1</span>, endIndex, sorted);        Merge(nums, startIndex, midIndex, endIndex, sorted);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span>* sorted = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * numsSize);    MergeSort(nums, <span class="hljs-number">0</span>, numsSize - <span class="hljs-number">1</span>, sorted);    <span class="hljs-built_in">free</span>(sorted);    *returnSize = numsSize;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h3><h4 id="6-1、步骤"><a href="#6-1、步骤" class="headerlink" title="6.1、步骤"></a>6.1、步骤</h4><p>快速排序是对冒泡排序的一种改进算法。</p><ol><li>在待排序表中任取一个元素p作为基准</li><li>通过一趟排序将待排序表分为两个子表，其中一个子表所有元素小于p，另一个子表多有元素大于p</li><li>递归地对上面两个字表进行1与2直至排序完成</li></ol><h4 id="6-2、实现"><a href="#6-2、实现" class="headerlink" title="6.2、实现"></a>6.2、实现</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* Nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;    <span class="hljs-keyword">if</span>(left&lt;right)&#123;        <span class="hljs-keyword">int</span> i=left,j=right,temp=Nums[left];        <span class="hljs-keyword">while</span>(i!=j)&#123;            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;Nums[j]&gt;temp)                j--;        <span class="hljs-keyword">if</span>(i&lt;j)            Nums[i++]=Nums[j];        <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;Nums[i]&lt;temp)            i++;        <span class="hljs-keyword">if</span>(i&lt;j)            Nums[j--]=Nums[i];        &#125;        Nums[i]=temp;<span class="hljs-comment">//</span>        quicksort(Nums,left,i<span class="hljs-number">-1</span>);        quicksort(Nums,i+<span class="hljs-number">1</span>,right);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize=numsSize;    quicksort(nums,<span class="hljs-number">0</span>,numsSize<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="7、堆排序"><a href="#7、堆排序" class="headerlink" title="7、堆排序"></a>7、堆排序</h3><h4 id="7-1、步骤"><a href="#7-1、步骤" class="headerlink" title="7.1、步骤"></a>7.1、步骤</h4><p>在排序的过程中，将待排序表看成是一棵完全二叉树的顺序存储结构，利用玩完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（最小）的元素。</p><ol><li>用待排序表构建初始堆</li><li>输出堆顶元素</li><li>用剩余元素构建大顶堆（小顶堆），重复1与2直至排序完成</li></ol><h4 id="7-2、实现"><a href="#7-2、实现" class="headerlink" title="7.2、实现"></a>7.2、实现</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AdjustDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> numsSize)</span></span>&#123;   <span class="hljs-comment">//向下调整</span>    <span class="hljs-keyword">int</span> temp = nums[a];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>;i&lt;numsSize;i=<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;numsSize &amp;&amp; nums[i+<span class="hljs-number">1</span>]&gt;nums[i])&#123;            i++;        &#125;        <span class="hljs-keyword">if</span>(temp &gt;= nums[i])&#123;            <span class="hljs-keyword">break</span>;        &#125;        nums[a] = nums[i];        a = i;    &#125;    nums[a] = temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    (*returnSize) = numsSize;    <span class="hljs-keyword">if</span>(numsSize &lt; <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> nums;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numsSize/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;          <span class="hljs-comment">//建大根堆</span>        AdjustDown(nums,i,numsSize);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numsSize<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;       <span class="hljs-comment">//排序</span>        <span class="hljs-keyword">int</span> temp = nums[<span class="hljs-number">0</span>];        nums[<span class="hljs-number">0</span>] = nums[i];        nums[i] = temp;        AdjustDown(nums,<span class="hljs-number">0</span>,i);    &#125;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre><h3 id="8、基数排序"><a href="#8、基数排序" class="headerlink" title="8、基数排序"></a>8、基数排序</h3><p>基数排序是一种特别的排序方法，它采用多关键字排序思想，借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先排序和最低位优先排序。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式总结</title>
    <link href="/2020/regular-expression/"/>
    <url>/2020/regular-expression/</url>
    
    <content type="html"><![CDATA[<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。<br><a id="more"></a></p><p>正则表达式经常会在项目中用到，但是通常不是很直观，不易理解。为了方便查阅便记录了一些常用的正则表达式。</p><blockquote><p>正则表达式：<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正则表达式–维基百科</a>、<a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">正则表达式–语法|菜鸟教程</a><br>正则可视化网站：<a href="http://wangwl.net/static/projects/visualRegex" target="_blank" rel="noopener">正则可视化</a>、<a href="https://regexper.com/" target="_blank" rel="noopener">Regexper</a>、<a href="https://www.debuggex.com/" target="_blank" rel="noopener">Debuggex</a>、<a href="https://jex.im/regulex" target="_blank" rel="noopener">Regulex</a><br>正则表达式测试：<a href="https://tool.oschina.net/regex#" target="_blank" rel="noopener">在线正则表达式测试</a>、<a href="http://c.runoob.com/front-end/854" target="_blank" rel="noopener">正则表达式在线测试丨菜鸟工具</a></p><p>本页面正则可视化均使用Regulex，若正则可视化显示错误请刷新页面或者点击图片右下角前往Regulex查看</p></blockquote><h3 id="1、邮箱"><a href="#1、邮箱" class="headerlink" title="1、邮箱"></a>1、邮箱</h3><h4 id="1-1、常用邮箱"><a href="#1-1、常用邮箱" class="headerlink" title="1.1、常用邮箱"></a>1.1、常用邮箱</h4><p>只允许英文字母、数字、下划线、英文句号、以及中划线组成<br><code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)+$</code></p><iframe frameborder="0" width="100%" height="350" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E%5Ba-zA-Z0-9_-%5D%2B%40%5Ba-zA-Z0-9-%5D%2B(%5C.%5Ba-zA-Z0-9-%5D%2B)%2B%24"></iframe> <h4 id="1-2、常用邮箱2"><a href="#1-2、常用邮箱2" class="headerlink" title="1.2、常用邮箱2"></a>1.2、常用邮箱2</h4><p><code>^[\w_-]+(?:\.[\w_-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?$</code></p><iframe frameborder="0" width="100%" height="260" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E%5B%5Cw_-%5D%2B(%3F%3A%5C.%5B%5Cw_-%5D%2B)*%40(%3F%3A%5B%5Cw%5D(%3F%3A%5B%5Cw-%5D*%5B%5Cw%5D)%3F%5C.)%2B%5B%5Cw%5D(%3F%3A%5B%5Cw-%5D*%5B%5Cw%5D)%3F%24"></iframe> <h3 id="2、电话-手机号码"><a href="#2、电话-手机号码" class="headerlink" title="2、电话/手机号码"></a>2、电话/手机号码</h3><h4 id="2-1、电话"><a href="#2-1、电话" class="headerlink" title="2.1、电话"></a>2.1、电话</h4><p>XXX-XXXXXXX XXXX-XXXXXXXX 格式的固定电话<br><code>(\(\d{3,4}\)|\d{3,4}-|\s)?\d{8}</code></p><iframe frameborder="0" width="100%" height="300" src="https://jex.im/regulex/#!embed=true&flags=&re=(%5C(%5Cd%7B3%2C4%7D%5C)%7C%5Cd%7B3%2C4%7D-%7C%5Cs)%3F%5Cd%7B8%7D"></iframe><h4 id="2-1、手机"><a href="#2-1、手机" class="headerlink" title="2.1、手机"></a>2.1、手机</h4><p>1XX XXXX XXXX的11位手机号<br><code>^1[^12]\d{9}$</code></p><iframe frameborder="0" width="100%" height="150" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E1%5B%5E12%5D%5Cd%7B9%7D%24"></iframe><h3 id="3、域名-URL"><a href="#3、域名-URL" class="headerlink" title="3、域名/URL"></a>3、域名/URL</h3><h4 id="3-1、通用"><a href="#3-1、通用" class="headerlink" title="3.1、通用"></a>3.1、通用</h4><p>支持所有的协议<br><code>[a-zA-z]+://[^\s]*</code></p><iframe frameborder="0" width="100%" height="190" src="https://jex.im/regulex/#!embed=true&flags=&re=%5Ba-zA-z%5D%2B%3A%2F%2F%5B%5E%5Cs%5D*"></iframe><h4 id="3-2、http-https协议"><a href="#3-2、http-https协议" class="headerlink" title="3.2、http/https协议"></a>3.2、http/https协议</h4><p><code>^((http:\/\/)|(https:\/\/))?([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}(\/)</code></p><iframe frameborder="0" width="100%" height="420" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E((http%3A%5C%2F%5C%2F)%7C(https%3A%5C%2F%5C%2F))%3F(%5Ba-zA-Z0-9%5D(%5Ba-zA-Z0-9%5C-%5D%7B0%2C61%7D%5Ba-zA-Z0-9%5D)%3F%5C.)%2B%5Ba-zA-Z%5D%7B2%2C6%7D(%5C%2F)"></iframe><h3 id="4、账号"><a href="#4、账号" class="headerlink" title="4、账号"></a>4、账号</h3><p>字母开头，允许4-16字节，允许字母数字下划线<br><code>^[a-zA-Z][a-zA-Z0-9_]{3,15}$</code></p><iframe frameborder="0" width="100%" height="260" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E%5Ba-zA-Z%5D%5Ba-zA-Z0-9_%5D%7B3%2C15%7D%24"></iframe><h3 id="5、IP地址"><a href="#5、IP地址" class="headerlink" title="5、IP地址"></a>5、IP地址</h3><p><code>((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</code></p><iframe frameborder="0" width="100%" height="370" src="https://jex.im/regulex/#!embed=true&flags=&re=((%3F%3A(%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C%5B01%5D%3F%5Cd%3F%5Cd)%5C.)%7B3%7D(%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C%5B01%5D%3F%5Cd%3F%5Cd))"></iframe>]]></content>
    
    
    <categories>
      
      <category>实用总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序表相关习题(C语言实现)</title>
    <link href="/2019/sequence-list/"/>
    <url>/2019/sequence-list/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h1><p>线性表的顺序存储又称为顺序表。它是一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的元素在物理上也相邻。<br><a id="more"></a><br>假定线性表的元素类型是ElemType，线性表的顺序存储类型描述为</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 100 <span class="hljs-comment">//表长初始值</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType; <span class="hljs-comment">//顺序表元素类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>ElemType data[MaxSize];<span class="hljs-comment">//表中数据元素</span><span class="hljs-keyword">int</span> Length;<span class="hljs-comment">//顺序表的当前长度</span>&#125;SqList;</code></pre><h1 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h1><h2 id="1、删除具有最小值的元素"><a href="#1、删除具有最小值的元素" class="headerlink" title="1、删除具有最小值的元素"></a>1、删除具有最小值的元素</h2><p>从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。</p><blockquote><p>思路：遍历顺序表找到最小元素，记录其位置，然后将其替换为最后一个元素。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">(SqList &amp;L, ElemType &amp;left)</span></span>&#123;    <span class="hljs-keyword">if</span> (L.Length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    left = L.data[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-comment">//最小值位置记录</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;        <span class="hljs-keyword">if</span> (L.data[i] &lt; left)&#123;           left = L.data[i];           pos = i;        &#125;    &#125;    L.data[pos] = L.data[L.Length<span class="hljs-number">-1</span>];    L.Length--;&#125;</code></pre><h2 id="2、元素逆置"><a href="#2、元素逆置" class="headerlink" title="2、元素逆置"></a>2、元素逆置</h2><p>设计一个高效的算法，将顺序表的所有元素逆置，要求算法的空间复杂度为O(1)。</p><blockquote><p>思路：将第i个元素和第n-i个元素互换。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;    <span class="hljs-keyword">if</span> (L.Length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">int</span> n = L.Length/<span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> tmp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;n; i++)&#123;        <span class="hljs-keyword">int</span> j = L.Length<span class="hljs-number">-1</span>-i;        tmp = L.data[i];        L.data[i] = L.data[j];        L.data[j] = tmp;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="3、删除所有值为X的数据元素"><a href="#3、删除所有值为X的数据元素" class="headerlink" title="3、删除所有值为X的数据元素"></a>3、删除所有值为X的数据元素</h2><p>长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除该线性表中所有值为x的数据元素。</p><blockquote><p>思路：遍历顺序表时记录值不为x的个数j，并将第i个元素移动至第j个。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValue</span><span class="hljs-params">(SqList &amp;L,ElemType value)</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;        <span class="hljs-keyword">if</span> (L.data[i] != value)&#123;            L.data[j] = L.data[i];            j++;        &#125;    &#125;    L.Length = j;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="4、有序表中删除值在给定区间的数据元素"><a href="#4、有序表中删除值在给定区间的数据元素" class="headerlink" title="4、有序表中删除值在给定区间的数据元素"></a>4、有序表中删除值在给定区间的数据元素</h2><p>从有序顺序表中删除其值在给定值s与t之间（要求s&lt;t）的所有元素，如果s或t不合理或者顺序表为空则显示出错信息并退出。</p><blockquote><p>解法1：遍历顺序表，元素值小于等于s时无操作；元素值在s与t之间时计数n加一，元素值大于等于t时元素前移n位。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValueBetweenST</span><span class="hljs-params">(SqList &amp;L, ElemType s, ElemType t)</span></span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(s &gt;= t || L.Length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;        <span class="hljs-keyword">if</span> (L.data[i] &gt; s &amp;&amp; L.data[i] &lt; t )&#123;            n++;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L.data[i] &gt;= t)&#123;            L.data[i-n] = L.data[i];        &#125;    &#125;    L.Length -= n;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><blockquote><p>解法2：与题目3类似，判断条件变为元素值不在s与t之间。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValueBetweenST</span><span class="hljs-params">(SqList &amp;L, ElemType s, ElemType t)</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(s &gt;= t || L.Length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;        <span class="hljs-keyword">if</span> (L.data[i] &lt;= s || L.data[i]&gt;= t )&#123;            L.data[j] = L.data[i];            j++;        &#125;    &#125;    L.Length = j;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="5、无序表中删除值在给定区间的数据元素"><a href="#5、无序表中删除值在给定区间的数据元素" class="headerlink" title="5、无序表中删除值在给定区间的数据元素"></a>5、无序表中删除值在给定区间的数据元素</h2><p>从顺序表中删除其值在给定值s与t之间（包含s和t，要求s&lt;t）的所有元素，如果s或t不合理或者顺序表为空则显示出错信息并退出。</p><blockquote><p>思路：与题目3类似，判断条件变为元素值小于s或者大于t。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValueBetweenST2</span><span class="hljs-params">(SqList &amp;L, ElemType s, ElemType t)</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(s &gt;= t || L.Length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;        <span class="hljs-keyword">if</span> (L.data[i] &lt; s || L.data[i]&gt; t )&#123;            L.data[j] = L.data[i];            j++;        &#125;    &#125;    L.Length = j;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="6、删除重复的的数据元素"><a href="#6、删除重复的的数据元素" class="headerlink" title="6、删除重复的的数据元素"></a>6、删除重复的的数据元素</h2><p>从有序顺序表中删除所有其值重复的元素。使表中所有元素值均不同。</p><blockquote><p>思路：遍历顺序表，依次判断当前元素与下一元素是否相同。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteSameValue</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L.Length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; L.Length; i++)&#123;        <span class="hljs-keyword">if</span> (L.data[j] != L.data[i])&#123;            L.data[j+<span class="hljs-number">1</span>] = L.data[i];            j++;        &#125;    &#125;    L.Length = j + <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="7、合并顺序表"><a href="#7、合并顺序表" class="headerlink" title="7、合并顺序表"></a>7、合并顺序表</h2><p>将两个有序顺序表合并成一个新的有序顺序表，并由函数返回结果顺序表</p><blockquote><p>思路：比较两个有序顺序表A与B的最小的元素，将最小元素放入顺序表L中。重复此操作。最后将A或者B中剩余未比较部分加入到表L。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(SqList &amp;L, SqList A, SqList B)</span></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>,k = <span class="hljs-number">0</span>;<span class="hljs-comment">//分别标记三个数组下标</span>    <span class="hljs-keyword">for</span> (; i &lt; A.Length || j &lt; B.Length; )&#123; <span class="hljs-comment">//比较大小，将较小的值放入顺序表L</span>        <span class="hljs-keyword">if</span>(A.data[i] &gt;= B.data[j])&#123;            L.data[k++] = B.data[j++];        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A.data[i] &lt; B.data[j])&#123;            L.data[k++] = A.data[i++];        &#125;    &#125;    <span class="hljs-keyword">while</span>( i &lt; A.Length)&#123;<span class="hljs-comment">//将比较完毕后剩余的元素加入表L</span>        L.data[k++] = A.data[i++];    &#125;    <span class="hljs-keyword">while</span>( j &lt; B.Length)&#123;        L.data[k++] = B.data[j++];    &#125;    L.Length = k;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="8、顺序表位置互换"><a href="#8、顺序表位置互换" class="headerlink" title="8、顺序表位置互换"></a>8、顺序表位置互换</h2><p>已知在一维数组A[m+n]中依次存放着两个线性表（$a_1,a_2,…,a_m$)与($b_1,b_2,…,b_n$)。试编写一个函数，将数组中两个顺序表的位置互换。</p><blockquote><p>思路：先整体逆置，再分别逆置0到n-1和n到n+m-1。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reverse</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-comment">//将顺序表的left到right逆置</span>    <span class="hljs-keyword">if</span> (L.Length == <span class="hljs-number">0</span> || left &gt; right || right &gt;= L.Length)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">int</span> n = (right + left)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> tmp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-left; i++)&#123;        tmp = L.data[left+i];        L.data[left+i] = L.data[right-i];        L.data[right-i] = tmp;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>&#123;    reverse(L, <span class="hljs-number">0</span>, m + n<span class="hljs-number">-1</span>);    reverse(L, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);    reverse(L, n, m + n<span class="hljs-number">-1</span>);&#125;</code></pre><h2 id="9、查找值为x的元素并与后继元素交换位置"><a href="#9、查找值为x的元素并与后继元素交换位置" class="headerlink" title="9、查找值为x的元素并与后继元素交换位置"></a>9、查找值为x的元素并与后继元素交换位置</h2><p>线性表（$a_1,a_2,…,a_m$)中元素递增有序且按照顺序存储于计算机中。要求设计一算法完成用最少时间在表中查找数值为x的元素，若找到将其与后继元素位置相交换，若找不到将其插入表中并使表中元素仍然有序。</p><blockquote><p>思路：查找时间最少，使用折半查找法。有值为x的函数则与下一元素交换位置，没有则将值大于x的元素后移一位，插入x。</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchValue</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> low, mid ,high;<span class="hljs-comment">//折半查找</span>    low = <span class="hljs-number">0</span>;    high = L.Length<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;        mid = (low + high)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(L.data[mid] &gt; x)&#123;            high = mid<span class="hljs-number">-1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.data[mid] &lt; x)&#123;            low = mid+<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(low &gt; high)&#123;<span class="hljs-comment">//无该元素则插入</span>        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">for</span> (i = L.Length<span class="hljs-number">-1</span>;L.data[i] &gt; x; i--)&#123; <span class="hljs-comment">//大于x的元素后移一位</span>            L.data[i+<span class="hljs-number">1</span>] = L.data[i];        &#125;        L.data[i+<span class="hljs-number">1</span>] = x;<span class="hljs-comment">//插入x</span>        L.Length++;    &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//有该元素则与下一元素交换</span>        <span class="hljs-keyword">int</span> tmp = L.data[mid];        L.data[mid] = L.data[mid+<span class="hljs-number">1</span>];        L.data[mid+<span class="hljs-number">1</span>] = tmp;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>数据结构</tag>
      
      <tag>顺序表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
