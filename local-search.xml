<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第十四周</title>
    <link href="/2021/leetcode-week-14/"/>
    <url>/2021/leetcode-week-14/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h4 id="706-设计哈希映射"><a href="#706-设计哈希映射" class="headerlink" title="706. 设计哈希映射"></a><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a></h4><p>日期：<code>2021/03/14</code></p><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 <code>MyHashMap</code> 类：</p><ul><li><code>MyHashMap()</code> 用空映射初始化对象</li><li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li><li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li><li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<br>[<span class="hljs-string">&quot;MyHashMap&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;remove&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br><span class="hljs-string">[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</span><br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, null, <span class="hljs-number">1</span>, null, <span class="hljs-number">-1</span>]<br><br>解释：<br>MyHashMap myHashMap = new MyHashMap();<br>myHashMap.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); // myHashMap 现在为 <span class="hljs-string">[[1,1]]</span><br>myHashMap.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); // myHashMap 现在为 <span class="hljs-string">[[1,1], [2,2]]</span><br>myHashMap.get(<span class="hljs-number">1</span>);    // 返回 <span class="hljs-number">1</span> ，myHashMap 现在为 <span class="hljs-string">[[1,1], [2,2]]</span><br>myHashMap.get(<span class="hljs-number">3</span>);    // 返回 <span class="hljs-number">-1</span>（未找到），myHashMap 现在为 <span class="hljs-string">[[1,1], [2,2]]</span><br>myHashMap.put(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>); // myHashMap 现在为 <span class="hljs-string">[[1,1], [2,1]]</span>（更新已有的值）<br>myHashMap.get(<span class="hljs-number">2</span>);    // 返回 <span class="hljs-number">1</span> ，myHashMap 现在为 <span class="hljs-string">[[1,1], [2,1]]</span><br>myHashMap.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>); // 删除键为 <span class="hljs-number">2</span> 的数据，myHashMap 现在为 <span class="hljs-string">[[1,1]]</span><br>myHashMap.get(<span class="hljs-number">2</span>);    // 返回 <span class="hljs-number">-1</span>（未找到），myHashMap 现在为 <span class="hljs-string">[[1,1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= key, value &lt;= 106</code></li><li>最多调用 <code>104</code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li></ul><p><strong>进阶：</strong>你能否不使用内置的 HashMap 库解决此问题？</p><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Pair&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                pair.setValue(value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(<span class="hljs-keyword">new</span> Pair(key, value));<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                <span class="hljs-keyword">return</span> pair.value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                data[h].remove(pair);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><p>日期：<code>2021/03/15</code></p><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        List&lt;Integer&gt; order = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> order;<br>        &#125;<br>        <span class="hljs-keyword">int</span> rows = matrix.length, columns = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][columns];<br>        <span class="hljs-keyword">int</span> total = rows * columns;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, column = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;<br>            order.add(matrix[row][column]);<br>            visited[row][column] = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextColumn = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="hljs-number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;<br>                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            &#125;<br>            row += directions[directionIndex][<span class="hljs-number">0</span>];<br>            column += directions[directionIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><p>日期：<code>2021/03/16</code></p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span> maxNum = n * n;<br>        <span class="hljs-keyword">int</span> curNum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, column = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 右下左上</span><br>        <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curNum &lt;= maxNum) &#123;<br>            matrix[row][column] = curNum;<br>            curNum++;<br>            <span class="hljs-keyword">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextColumn = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="hljs-number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="hljs-number">0</span>) &#123;<br>                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>; <span class="hljs-comment">// 顺时针旋转至下一个方向</span><br>            &#125;<br>            row = row + directions[directionIndex][<span class="hljs-number">0</span>];<br>            column = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列</a></h4><p>日期：<code>2021/03/17</code></p><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。<br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>rabbbit<br>^^^<span class="hljs-built_in">^</span> <span class="hljs-built_in">^</span><span class="hljs-built_in">^</span><br>rabbbit<br>^^ ^^^<span class="hljs-built_in">^</span><br>rabbbit<br>^^^ ^^^<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：s = <span class="hljs-string">&quot;babgbag&quot;</span>, t = <span class="hljs-string">&quot;bag&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">5</span> 种可以从 s 中得到 <span class="hljs-string">&quot;bag&quot;</span> 的方案。 <br>(上箭头符号 ^ 表示选取的字母)<br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword">^^ </span>^<br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword">^^ </span>   ^<br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword">^ </span>   ^^<br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"> </span> ^  ^^<br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"> </span>   ^^^<br></code></pre></td></tr></table></figure><h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.length(), n = t.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>            dp[i][n] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">char</span> sChar = s.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">char</span> tChar = t.charAt(j);<br>                <span class="hljs-keyword">if</span> (sChar == tChar) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/distinct-subsequences/solution/bu-tong-de-zi-xu-lie-by-leetcode-solutio-urw3/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p>日期：<code>2021/03/18</code></p><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">left</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">right</span> = <span class="hljs-number">4</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">5</span>], <span class="hljs-attr">left</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">right</span> = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p><h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 添加头结点</span><br>        ListNode current = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode ans = current;<br>        current.next = head;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 排除前面无需反转的部分</span><br>        <span class="hljs-keyword">while</span>(pos &lt; left - <span class="hljs-number">1</span>)&#123;<br>            current = current.next;<br>            pos++;<br>        &#125;<br>        <span class="hljs-comment">// 反转left到right的部分</span><br>        ListNode leftNode = current.next;<br>        ListNode rightNode = leftNode.next;<br>        pos++;<br>        <span class="hljs-keyword">while</span>(pos &lt; right)&#123;<br>            ListNode tmp = rightNode.next;<br>            rightNode.next = leftNode;<br>            leftNode = rightNode;<br>            rightNode = tmp;<br>            pos++;<br>        &#125;<br>        <span class="hljs-comment">// 将反转后的链表重新链接到原链表上</span><br>        current.next.next = rightNode;<br>        current.next = leftNode;<br>        <span class="hljs-keyword">return</span> ans.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第十三周</title>
    <link href="/2021/leetcode-week-13/"/>
    <url>/2021/leetcode-week-13/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h4><p>日期：<code>2021/03/07</code></p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[][] f;<br>    List&lt;List&lt;String&gt;&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">int</span> n;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;<br>        n = s.length();<br>        f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(f[i], <span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                f[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        dfs(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == n) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(ans));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (f[i][j]) &#123;<br>                ans.add(s.substring(i, j + <span class="hljs-number">1</span>));<br>                dfs(s, j + <span class="hljs-number">1</span>);<br>                ans.remove(ans.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h4><p>日期：<code>2021/03/08</code></p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 <strong>最少分割次数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：只需一次分割就可将 s 分割成 [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>] 这样两个回文子串。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(g[i], <span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                g[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(f, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][i]) &#123;<br>                f[i] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (g[j + <span class="hljs-number">1</span>][i]) &#123;<br>                        f[i] = Math.min(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/palindrome-partitioning-ii/solution/fen-ge-hui-wen-chuan-ii-by-leetcode-solu-norx/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4><p>日期：<code>2021/03/09</code></p><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;abbaca&quot;</span><br>输出：<span class="hljs-string">&quot;ca&quot;</span><br>解释：<br>例如，在 <span class="hljs-string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="hljs-string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="hljs-string">&quot;aaca&quot;</span>，其中又只有 <span class="hljs-string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="hljs-string">&quot;ca&quot;</span>。<br></code></pre></td></tr></table></figure><h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><p>字符依次入栈，若入栈元素与栈顶元素相同则出栈并跳过该元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(String S)</span> </span>&#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-comment">// 依次入栈，若相邻元素相同则消除</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : S.toCharArray())&#123;<br>            <span class="hljs-comment">// 元素相同，弹出栈顶元素</span><br>            <span class="hljs-keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == ch)&#123;<br>                stack.pop();<br>            &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// 元素不同，正常入栈</span><br>                stack.push(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将剩余字符取出</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            ans.append(stack.pop());<br>        &#125;<br>        <span class="hljs-comment">// 需要反转字符串之后再返回结果</span><br>        <span class="hljs-keyword">return</span> ans.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></h4><p>日期：<code>2021/03/10</code></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1 + 1&quot;</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot; 2-1 + 2 &quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：s = &quot;(1+(4<span class="hljs-string">+5</span><span class="hljs-string">+2</span>)<span class="hljs-string">-3</span>)+(6<span class="hljs-string">+8</span>)&quot;<br>输出：23<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li></ul><h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Deque&lt;Integer&gt; ops = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        ops.push(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = ops.peek();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                sign = -ops.peek();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.push(sign);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                ops.pop();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;<br>                    num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                ret += sign * num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/basic-calculator/solution/ji-ben-ji-suan-qi-by-leetcode-solution-jvir/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></h4><p>日期：<code>2021/03/11</code></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;3+2*2&quot;</span><br>输出：<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot; 3/2 &quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot; 3+5 / 2 &quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li><li><code>s</code> 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul><h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        <span class="hljs-keyword">char</span> preSign = <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>                num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">switch</span> (preSign) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        stack.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        stack.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        stack.push(stack.pop() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stack.push(stack.pop() / num);<br>                &#125;<br>                preSign = s.charAt(i);<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            ans += stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化</a></h4><p>日期：<code>2021/03/12</code></p><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     _9_<br>    /   <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>     <span class="hljs-number">2</span><br>  / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br> <span class="hljs-number">4</span>   <span class="hljs-number">1</span>  <span class="hljs-comment">#  6</span><br>/ <span class="hljs-string">\</span> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-comment"># # # #   # #</span><br></code></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;1,#&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;9,#,#,1&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h5 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(<span class="hljs-keyword">String</span> preorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = preorder.length();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span>.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (preorder.charAt(i) == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preorder.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                <span class="hljs-keyword">int</span> top = <span class="hljs-built_in">stack</span>.pop() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">stack</span>.push(top);<br>                &#125;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 读一个数字</span><br>                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; preorder.charAt(i) != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">int</span> top = <span class="hljs-built_in">stack</span>.pop() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">stack</span>.push(top);<br>                &#125;<br>                <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>.isEmpty();<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a></h4><p>日期：<code>2021/03/13</code></p><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 <code>MyHashSet</code> 类：</p><ul><li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li><li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li><li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入：<br>[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>]]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>]<br><br>解释：<br>MyHashSet myHashSet = <span class="hljs-built_in">new</span> MyHashSet();<br>myHashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);      // <span class="hljs-keyword">set</span> = [<span class="hljs-number">1</span>]<br>myHashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);      // <span class="hljs-keyword">set</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>myHashSet.contains(<span class="hljs-number">1</span>); // 返回 <span class="hljs-keyword">True</span><br>myHashSet.contains(<span class="hljs-number">3</span>); // 返回 <span class="hljs-keyword">False</span> ，（未找到）<br>myHashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);      // <span class="hljs-keyword">set</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>myHashSet.contains(<span class="hljs-number">2</span>); // 返回 <span class="hljs-keyword">True</span><br>myHashSet.remove(<span class="hljs-number">2</span>);   // <span class="hljs-keyword">set</span> = [<span class="hljs-number">1</span>]<br>myHashSet.contains(<span class="hljs-number">2</span>); // 返回 <span class="hljs-keyword">False</span> ，（已移除）<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= key &lt;= 106</code></li><li>最多调用 <code>104</code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code> 。</li></ul><h5 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                data[h].remove(element);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第十二周</title>
    <link href="/2021/leetcode-week-12/"/>
    <url>/2021/leetcode-week-12/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h4 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896. 单调数列"></a><a href="https://leetcode-cn.com/problems/monotonic-array/">896. 单调数列</a></h4><p>日期：<code>2021/02/28</code></p><p>如果数组是单调递增或单调递减的，那么它是<em>单调的</em>。</p><p>如果对于所有 <code>i &lt;= j</code>，<code>A[i] &lt;= A[j]</code>，那么数组 <code>A</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>A[i]&gt; = A[j]</code>，那么数组 <code>A</code> 是单调递减的。</p><p>当给定的数组 <code>A</code> 是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 50000</code></li><li><code>-100000 &lt;= A[i] &lt;= 100000</code></li></ol><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMonotonic</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = A.length;<br>        <span class="hljs-keyword">boolean</span> isUpper = <span class="hljs-keyword">true</span>, isLower = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; A[i - <span class="hljs-number">1</span>])&#123;<br>                isLower = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i] &lt; A[i - <span class="hljs-number">1</span>])&#123;<br>                isUpper = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isUpper || isLower;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h4><p>日期：<code>2021/03/01</code></p><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p><strong>示例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：<br>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]<br>[[[<span class="hljs-string">-2</span>, 0, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>]], [0, 2], [2, 5], [0, 5]]<br>输出：<br>[null, 1, <span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>]<br><br>解释：<br>NumArray numArray = new NumArray([<span class="hljs-string">-2</span>, 0, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>]);<br>numArray.sumRange(0, 2); // return 1 ((<span class="hljs-string">-2</span>) + 0 + 3)<br>numArray.sumRange(2, 5); // return <span class="hljs-string">-1</span> (3 + (<span class="hljs-string">-5</span>) + 2 + (<span class="hljs-string">-1</span>)) <br>numArray.sumRange(0, 5); // return <span class="hljs-string">-3</span> ((<span class="hljs-string">-2</span>) + 0 + 3 + (<span class="hljs-string">-5</span>) + 2 + (<span class="hljs-string">-1</span>))<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>104</code> 次 <code>sumRange</code> 方法</li></ul><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>方法一：直接遍历<code>i</code>到<code>j</code>计算总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span>[] nums;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.nums = nums;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n = i; n &lt;= j; n++)&#123;<br>            sum += nums[n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(i,j);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>方法二</p><p>初始化时先计算每个元素到<code>0</code>累计总和。需要计算<code>i</code>到<code>j</code>的总和只需要<code>0</code>到<code>j</code>的总和减去<code>0</code>到<code>i - 1</code>总和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span>[] sums;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n =nums.length;<br>        sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>            sums[i + <span class="hljs-number">1</span>] = sum;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sums[j + <span class="hljs-number">1</span>] - sums[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(i,j);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h4><p>日期：<code>2021/03/02</code></p><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/images/304.png" alt="Range Sum Query 2D"><br>上图子矩阵左上角 (row1, col1) = <strong>(2, 1)</strong> ，右下角(row2, col2) = <strong>(4, 3)，</strong>该子矩形内元素的总和为 8。</p><p><strong>示例：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定 matrix = [<br>  [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>],<br>  [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>],<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>]<br>]<br><br>sumRegion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-number">8</span><br>sumRegion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> <span class="hljs-number">11</span><br>sumRegion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span> -&gt;</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>你可以假设矩阵不可变。</li><li>会多次调用 <code>sumRegion</code> 方法<em>。</em></li><li>你可以假设 <code>row1 ≤ row2</code> 且 <code>col1 ≤ col2</code> 。</li></ul><h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><p>方法一：直接遍历计算总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span>[][] matrix;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.matrix = matrix;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row1; i &lt;= row2; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = col1; j &lt;= col2; j++)&#123;<br>                sum += matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>方法二：先计算每个位置的二维累计总和，然后进行加减。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span>[][] sums;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rowLen = matrix.length;<br>        <span class="hljs-keyword">if</span>(rowLen == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> colLen = matrix[<span class="hljs-number">0</span>].length;<br>        sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rowLen + <span class="hljs-number">1</span>][colLen + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowLen; i++)&#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colLen; j++)&#123;<br>                sum += matrix[i][j];<br>                sums[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = sums[i][j + <span class="hljs-number">1</span>] + sum;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sums[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] + sums[row1][col1] - sums[row1][col2 + <span class="hljs-number">1</span>] - sums[row2 + <span class="hljs-number">1</span>][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h4><p>日期：<code>2021/03/03</code></p><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><br><span class="hljs-section">输出: [0,1,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 5</span><br><span class="hljs-section">输出: [0,1,1,2,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>给出时间复杂度为<strong>O(n*sizeof(integer))</strong>的解答非常容易。但你可以在线性时间<strong>O(n)</strong>内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为<strong>O(n)</strong>。</li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <strong>__builtin_popcount</strong>）来执行此操作。</li></ul><h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><p>将每个数字的二进制形式拆分为末尾位和其他位。其他位<code>1</code>的数量总和与其他位右移一位后的数字相同。末尾位只能为<code>1</code>或者<code>0</code>，对当前数字进行模运算即可获取。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-built_in">int</span>[] countBits(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>) &#123;<br>        <span class="hljs-built_in">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-built_in">num</span> + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">num</span> + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-comment">// 除运算与模运算</span><br>            <span class="hljs-comment">// ans[i] = ans[i / 2] + (i % 2);</span><br>            <span class="hljs-comment">// 位运算（效率更高）</span><br>            ans[i] = ans[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h4><p>日期：<code>2021/03/04</code></p><p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>注意</strong>：不允许旋转信封。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：envelopes = <span class="hljs-comment">[<span class="hljs-comment">[5,4]</span>,<span class="hljs-comment">[6,4]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：3<br>解释：最多信封的个数为 3, 组合为: <span class="hljs-comment">[2,3]</span> =&gt; <span class="hljs-comment">[5,4]</span> =&gt; <span class="hljs-comment">[6,7]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：envelopes = <span class="hljs-string">[[1,1],[1,1],[1,1]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= envelopes.length &lt;= 5000</code></li><li><code>envelopes[i].length == 2</code></li><li><code>1 &lt;= wi, hi &lt;= 104</code></li></ul><h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] envelopes)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (envelopes.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> n = envelopes.length;<br>        Arrays.sort(envelopes, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] e1, <span class="hljs-keyword">int</span>[] e2)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (e1[<span class="hljs-number">0</span>] != e2[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">return</span> e1[<span class="hljs-number">0</span>] - e2[<span class="hljs-number">0</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> e2[<span class="hljs-number">1</span>] - e1[<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(f, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>]) &#123;<br>                    f[i] = Math.max(f[i], f[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            ans = Math.max(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/russian-doll-envelopes/solution/e-luo-si-tao-wa-xin-feng-wen-ti-by-leetc-wj68/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><p>日期：<code>2021/03/05</code></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p><strong>示例：</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">输入：<br>[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>]<br><br>解释：<br>MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();<br>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span><br>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span><br>myQueue.peek(); <span class="hljs-comment">// return 1</span><br>myQueue.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span><br>myQueue.empty(); <span class="hljs-comment">// return false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><h5 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <br>    Deque&lt;Integer&gt; stackIn;<br>    Deque&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        stackIn = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>   <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br>    <br>   <span class="hljs-comment">// 栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 判断是否为空栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4><p>日期：<code>2021/03/06</code></p><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,1]</span><br><span class="hljs-section">输出: [2,-1,2]</span><br><span class="hljs-section">解释: 第一个 1 的下一个更大的数是 2；</span><br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p><h5 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h5><p>使用<code>map</code>保存暂时未找到下一个更大元素的元素，遍历数组时若当前元素大于<code>map</code>中的元素则移除该元素。最多遍历两遍数组即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-comment">// 默认值为-1</span><br>        Arrays.fill(ans, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 必须使用ConcurrentHashMap才能在遍历的时候进行修改</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>        <span class="hljs-comment">// 循环遍历数组，最多遍历两次</span><br>        <span class="hljs-keyword">while</span>(pos &lt; <span class="hljs-number">2</span> * n)&#123;<br>            <span class="hljs-keyword">int</span> i = pos % n; <br>            <span class="hljs-comment">// 将当前元素存入map</span><br>            map.put(i, nums[i]);<br>            <span class="hljs-comment">// 查找map中是否有比当前元素小的元素</span><br>            <span class="hljs-comment">// 若有则将其指针指向当前元素</span><br>            <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>                <span class="hljs-keyword">if</span>(entry.getValue() &lt; nums[i])&#123;<br>                    ans[entry.getKey()] = nums[i];<br>                    map.remove(entry.getKey());<br>                &#125;<br>            &#125;<br>            pos++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第十一周</title>
    <link href="/2021/leetcode-week-11/"/>
    <url>/2021/leetcode-week-11/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h4><p>日期：<code>2021/02/21</code></p><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p><p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：nums = [<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>], limit = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span> <br>解释：所有子数组如下：<br>[<span class="hljs-number">8</span>] 最大绝对差 |<span class="hljs-type">8</span><span class="hljs-number">-8</span>| <span class="hljs-type">= 0</span> &lt;= <span class="hljs-number">4.</span><br>[<span class="hljs-number">8</span>,<span class="hljs-number">2</span>] 最大绝对差 |<span class="hljs-type">8</span><span class="hljs-number">-2</span>| <span class="hljs-type">= 6</span> &gt; <span class="hljs-number">4.</span> <br>[<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] 最大绝对差 |<span class="hljs-type">8</span><span class="hljs-number">-2</span>| <span class="hljs-type">= 6</span> &gt; <span class="hljs-number">4.</span><br>[<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>] 最大绝对差 |<span class="hljs-type">8</span><span class="hljs-number">-2</span>| <span class="hljs-type">= 6</span> &gt; <span class="hljs-number">4.</span><br>[<span class="hljs-number">2</span>] 最大绝对差 |<span class="hljs-type">2</span><span class="hljs-number">-2</span>| <span class="hljs-type">= 0</span> &lt;= <span class="hljs-number">4.</span><br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] 最大绝对差 |<span class="hljs-type">2</span><span class="hljs-number">-4</span>| <span class="hljs-type">= 2</span> &lt;= <span class="hljs-number">4.</span><br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>] 最大绝对差 |<span class="hljs-type">2</span><span class="hljs-number">-7</span>| <span class="hljs-type">= 5</span> &gt; <span class="hljs-number">4.</span><br>[<span class="hljs-number">4</span>] 最大绝对差 |<span class="hljs-type">4</span><span class="hljs-number">-4</span>| <span class="hljs-type">= 0</span> &lt;= <span class="hljs-number">4.</span><br>[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>] 最大绝对差 |<span class="hljs-type">4</span><span class="hljs-number">-7</span>| <span class="hljs-type">= 3</span> &lt;= <span class="hljs-number">4.</span><br>[<span class="hljs-number">7</span>] 最大绝对差 |<span class="hljs-type">7</span><span class="hljs-number">-7</span>| <span class="hljs-type">= 0</span> &lt;= <span class="hljs-number">4.</span> <br>因此，满足题意的最长子数组的长度为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：nums = [<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>], limit = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">4</span> <br>解释：满足题意的最长子数组是 [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]，其最大绝对差 |<span class="hljs-type">2</span><span class="hljs-number">-7</span>| <span class="hljs-type">= 5</span> &lt;= <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,2,2,2</span>,<span class="hljs-number">4,4,2,2</span>], limit = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>0 &lt;= limit &lt;= 10^9</code></li></ul><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>使用滑动窗口+有序的TreeMap，依次后移查找符合要求的自己</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 有序键值对用来存储窗口内的值与数量</span><br>        TreeMap&lt;Integer, Integer&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-comment">// 将右指针的值加入窗口</span><br>            <span class="hljs-keyword">int</span> countR = treeMap.getOrDefault(nums[right], <span class="hljs-number">0</span>);<br>            treeMap.put(nums[right], countR + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 判断当前窗口内元素是否符合要求</span><br>            <span class="hljs-keyword">if</span>(treeMap.lastKey() - treeMap.firstKey() &gt; limit)&#123;<br>                <span class="hljs-keyword">int</span> countL = treeMap.get(nums[left]);<br>                <span class="hljs-keyword">if</span>(countL &gt; <span class="hljs-number">1</span>)&#123;<br>                    treeMap.put(nums[left], countL - <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    treeMap.remove(nums[left]);<br>                &#125;<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        ans = right - left;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a></h4><p>日期：<code>2021/02/22</code></p><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p><p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>在上述矩阵中, 其对角线为: <br><span class="hljs-string">&quot;[9]&quot;</span>, <span class="hljs-string">&quot;[5, 5]&quot;</span>, <span class="hljs-string">&quot;[1, 1, 1]&quot;</span>, <span class="hljs-string">&quot;[2, 2, 2]&quot;</span>, <span class="hljs-string">&quot;[3, 3]&quot;</span>, <span class="hljs-string">&quot;[4]&quot;</span>。 <br>各条对角线上的所有元素均相同, 因此答案是 True 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[2,2]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：<br>对角线 <span class="hljs-string">&quot;[1, 2]&quot;</span> 上的元素不同。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 20</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li><li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li></ul><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>遍历整个二维数组检查</p><p>我选择的是每次检查一个对角线。也可以依次遍历，与其左上角元素比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isToeplitzMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> lenRow = matrix.length;<br>        <span class="hljs-keyword">int</span> lenCol = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 遍历左下区域</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lenRow; i++)&#123;<br>            <span class="hljs-keyword">int</span> row = i;<br>            <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> num = matrix[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">while</span>(col &lt; lenCol &amp;&amp; row &lt; lenRow)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[row][col] != num)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                row++;<br>                col++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 遍历右上区域</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lenCol; i++)&#123;<br>            <span class="hljs-keyword">int</span> col = i;<br>            <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> num = matrix[<span class="hljs-number">0</span>][i];<br>            <span class="hljs-keyword">while</span>(col &lt; lenCol &amp;&amp; row &lt; lenRow)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[row][col] != num)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                row++;<br>                col++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></h4><p>日期：<code>2021/02/23</code></p><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3<br>输出：16<br>解释：<br>书店老板在最后<span class="hljs-number"> 3 </span>分钟保持冷静。<br>感到满意的最大客户数量 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 5 </span>= 16.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>0 &lt;= grumpy[i] &lt;= 1</code></li></ul><h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><p>使用滑动窗口找出连续<code>X</code>分钟内最大的不满意人数，同时记录满意人数总和，两者相加即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] customers, <span class="hljs-keyword">int</span>[] grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = customers.length;<br>        <span class="hljs-keyword">int</span> satisfaction = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 满意的人数</span><br>        <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 抑制情绪所能减少的最大不满意人数</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前窗口内不满意的人数</span><br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-comment">// 将右指针的节点加入窗口</span><br>            <span class="hljs-keyword">if</span>(grumpy[right] == <span class="hljs-number">0</span>)&#123;<br>                satisfaction += customers[right];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count += customers[right];<br>            &#125;<br>            maxCount = Math.max(maxCount, count);<br>            <span class="hljs-comment">// 窗口右移</span><br>            <span class="hljs-keyword">int</span> len = right -left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(len &gt;= X &amp;&amp; grumpy[left++] == <span class="hljs-number">1</span>)&#123;<br>                count -= customers[left -  <span class="hljs-number">1</span>];<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> satisfaction + maxCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/">832. 翻转图像</a></h4><p>日期：<code>2021/02/24</code></p><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p><p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p><p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-string">[[1,1,0],[1,0,1],[0,0,0]]</span><br>输出：<span class="hljs-string">[[1,0,0],[0,1,0],[1,1,1]]</span><br>解释：首先翻转每一行: <span class="hljs-string">[[0,1,1],[1,0,1],[0,0,0]]</span>；<br>     然后反转图片: <span class="hljs-string">[[1,0,0],[0,1,0],[1,1,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[1,0,0,1]</span>,<span class="hljs-comment">[0,1,1,1]</span>,<span class="hljs-comment">[1,0,1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[0,1,1,0]</span>,<span class="hljs-comment">[0,0,0,1]</span>,<span class="hljs-comment">[1,0,1,0]</span>]</span><br>解释：首先翻转每一行: <span class="hljs-comment">[<span class="hljs-comment">[0,0,1,1]</span>,<span class="hljs-comment">[1,0,0,1]</span>,<span class="hljs-comment">[1,1,1,0]</span>,<span class="hljs-comment">[0,1,0,1]</span>]</span>；<br>     然后反转图片: <span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[0,1,1,0]</span>,<span class="hljs-comment">[0,0,0,1]</span>,<span class="hljs-comment">[1,0,1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li><li><code>0 &lt;= A[i][j] &lt;= 1</code></li></ul><h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><p>可以在一次遍历中水平翻转并使用异或反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] flipAndInvertImage(<span class="hljs-keyword">int</span>[][] A) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> n = A[<span class="hljs-number">0</span>].length;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;(n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j++)&#123;<br>                <span class="hljs-comment">// 水平翻转并反转</span><br>                <span class="hljs-keyword">int</span> temp = A[i][j] ^ <span class="hljs-number">1</span>;<br>                A[i][j] = A[i][n - j - <span class="hljs-number">1</span>] ^ <span class="hljs-number">1</span>;<br>                A[i][n - j - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a><a href="https://leetcode-cn.com/problems/transpose-matrix/">867. 转置矩阵</a></h4><p>日期：<code>2021/02/25</code></p><p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p><p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[1,4,7],[2,5,8],[3,6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-string">[[1,4],[2,5],[3,6]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li></ul><h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] transpose(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <span class="hljs-keyword">int</span> m = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                ans[j][i] = matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178. 猜字谜"></a><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/">1178. 猜字谜</a></h4><p>日期：<code>2021/02/26</code></p><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li><li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</li></ul><p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p><p><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>words = [<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;asas&quot;</span>,<span class="hljs-string">&quot;able&quot;</span>,<span class="hljs-string">&quot;ability&quot;</span>,<span class="hljs-string">&quot;actt&quot;</span>,<span class="hljs-string">&quot;actor&quot;</span>,<span class="hljs-string">&quot;access&quot;</span>], <br>puzzles = [<span class="hljs-string">&quot;aboveyz&quot;</span>,<span class="hljs-string">&quot;abrodyz&quot;</span>,<span class="hljs-string">&quot;abslute&quot;</span>,<span class="hljs-string">&quot;absoryz&quot;</span>,<span class="hljs-string">&quot;actresz&quot;</span>,<span class="hljs-string">&quot;gaswxyz&quot;</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>]<br>解释：<br><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">&quot;aboveyz&quot;</span> 的谜底 : <span class="hljs-string">&quot;aaaa&quot;</span> <br><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">&quot;abrodyz&quot;</span> 的谜底 : <span class="hljs-string">&quot;aaaa&quot;</span><br><span class="hljs-number">3</span> 个单词可以作为 <span class="hljs-string">&quot;abslute&quot;</span> 的谜底 : <span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-string">&quot;asas&quot;</span>, <span class="hljs-string">&quot;able&quot;</span><br><span class="hljs-number">2</span> 个单词可以作为 <span class="hljs-string">&quot;absoryz&quot;</span> 的谜底 : <span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-string">&quot;asas&quot;</span><br><span class="hljs-number">4</span> 个单词可以作为 <span class="hljs-string">&quot;actresz&quot;</span> 的谜底 : <span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-string">&quot;asas&quot;</span>, <span class="hljs-string">&quot;actt&quot;</span>, <span class="hljs-string">&quot;access&quot;</span><br>没有单词可以作为 <span class="hljs-string">&quot;gaswxyz&quot;</span> 的谜底，因为列表中的单词都不含字母 <span class="hljs-string">&#x27;g&#x27;</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^5</code></li><li><code>4 &lt;= words[i].length &lt;= 50</code></li><li><code>1 &lt;= puzzles.length &lt;= 10^4</code></li><li><code>puzzles[i].length == 7</code></li><li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li><li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li></ul><h5 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    TrieNode root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findNumOfValidWords</span><span class="hljs-params">(String[] words, String[] puzzles)</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> TrieNode();<br>        <br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-comment">// 将 word 中的字母按照字典序排序并去重</span><br>            <span class="hljs-keyword">char</span>[] arr = word.toCharArray();<br>            Arrays.sort(arr);<br>            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || arr[i] != arr[i - <span class="hljs-number">1</span>]) &#123;<br>                    sb.append(arr[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 加入字典树中</span><br>            add(root, sb.toString());<br>        &#125;<br><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (String puzzle : puzzles) &#123;<br>            <span class="hljs-keyword">char</span> required = puzzle.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">char</span>[] arr = puzzle.toCharArray();<br>            Arrays.sort(arr);<br>            ans.add(find(<span class="hljs-keyword">new</span> String(arr), required, root, <span class="hljs-number">0</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(TrieNode root, String word)</span> </span>&#123;<br>        TrieNode cur = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); ++i) &#123;<br>            <span class="hljs-keyword">char</span> ch = word.charAt(i);<br>            <span class="hljs-keyword">if</span> (cur.child[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                cur.child[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>            &#125;<br>            cur = cur.child[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        ++cur.frequency;<br>    &#125;<br><br>    <span class="hljs-comment">// 在回溯的过程中枚举 puzzle 的所有子集并统计答案</span><br>    <span class="hljs-comment">// find(puzzle, required, cur, pos) 表示 puzzle 的首字母为 required, 当前搜索到字典树上的 cur 节点，并且准备枚举 puzzle 的第 pos 个字母是否选择（放入子集中）</span><br>    <span class="hljs-comment">// find 函数的返回值即为谜底的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(String puzzle, <span class="hljs-keyword">char</span> required, TrieNode cur, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索到空节点，不合法，返回 0</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 整个 puzzle 搜索完毕，返回谜底的数量</span><br>        <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">7</span>) &#123;<br>            <span class="hljs-keyword">return</span> cur.frequency;<br>        &#125;<br><br>        <span class="hljs-comment">// 选择第 pos 个字母</span><br>        <span class="hljs-keyword">int</span> ret = find(puzzle, required, cur.child[puzzle.charAt(pos) - <span class="hljs-string">&#x27;a&#x27;</span>], pos + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 当 puzzle.charAt(pos) 不为首字母时，可以不选择第 pos 个字母</span><br>        <span class="hljs-keyword">if</span> (puzzle.charAt(pos) != required) &#123;<br>            ret += find(puzzle, required, cur, pos + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> frequency;<br>    TrieNode[] child;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;<br>        frequency = <span class="hljs-number">0</span>;<br>        child = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h4><p>日期：<code>2021/02/27</code></p><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaabb&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：最长子串为 <span class="hljs-string">&quot;aaa&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">3</span> 次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ababbc&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span><br>解释：最长子串为 <span class="hljs-string">&quot;ababb&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">2</span> 次， &#x27;b&#x27; 重复了 <span class="hljs-number">3</span> 次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文字母组成</li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h5 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h5><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">26</span>; t++) &#123;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> less = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (r &lt; n) &#123;<br>                cnt[s.charAt(r) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                <span class="hljs-keyword">if</span> (cnt[s.charAt(r) - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                    tot++;<br>                    less++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cnt[s.charAt(r) - <span class="hljs-string">&#x27;a&#x27;</span>] == k) &#123;<br>                    less--;<br>                &#125;<br><br>                <span class="hljs-keyword">while</span> (tot &gt; t) &#123;<br>                    cnt[s.charAt(l) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                    <span class="hljs-keyword">if</span> (cnt[s.charAt(l) - <span class="hljs-string">&#x27;a&#x27;</span>] == k - <span class="hljs-number">1</span>) &#123;<br>                        less++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cnt[s.charAt(l) - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                        tot--;<br>                        less--;<br>                    &#125;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) &#123;<br>                    ret = Math.max(ret, r - l + <span class="hljs-number">1</span>);<br>                &#125;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用QTTabBar增强资源管理器</title>
    <link href="/2021/qttabbar/"/>
    <url>/2021/qttabbar/</url>
    
    <content type="html"><![CDATA[<p>QTTabBar是一款增强改造资源管理器的插件。Windows资源管理器的实质其实就是一款特殊的浏览器，并且可以加载IE插件。QTTabBar通过插件的方式为资源管理器提供了多标签栏、群组和收藏等功能。</p><a id="more"></a><h3 id="1、-安装"><a href="#1、-安装" class="headerlink" title="1、 安装"></a>1、 安装</h3><p>首先我们下载并安装QTTabBar，进入官网下载。有时QTTabBar会发布增量包，需要先下载增量包发布之前的完整版本才能继续安装。</p><p><a href="http://qttabbar.wikidot.com/">下载地址</a></p><p><img src="https://static.kezi.xyz/images/post/2021/qttabbar-1.png" alt=""></p><h3 id="2、启用"><a href="#2、启用" class="headerlink" title="2、启用"></a>2、启用</h3><p>QTTabBar安装完成后再次打开资源管理器，你可能会发现资源管理器毫无变化。这是因为QTTabBar作为插件还没有被启用 。点击查看 - 选项 - 勾选QTTabBar即可启用插件</p><p><img src="https://static.kezi.xyz/images/post/2021/qttabbar-2.png" alt=""></p><p>可以看见其实还有很多的选项可以选择，QTTabBar是最基础的标签栏。</p><h3 id="3、-汉化"><a href="#3、-汉化" class="headerlink" title="3、 汉化"></a>3、 汉化</h3><p>启用完成之后我们还需要进行汉化操作</p><p>首先在标签页右边空白处右键唤出菜单栏 - 点击QTTabBar Options</p><p><img src="https://static.kezi.xyz/images/post/2021/qttabbar-3.png" alt=""></p><p>在General选项卡中找到Download Language File的按钮</p><p><img src="https://static.kezi.xyz/images/post/2021/qttabbar-4.png" alt=""></p><p>按日期排序之后找到最新的中文翻译文件，双击下载。文件可以放在我的文档或者安装目录下。</p><p><img src="https://static.kezi.xyz/images/post/2021/qttabbar-5.png" alt=""></p><p>最后选择你下载的文件，应用即可</p><p><img src="https://static.kezi.xyz/images/post/2021/qttabbar-6.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QTTabBar</tag>
      
      <tag>资源管理器</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第十周</title>
    <link href="/2021/leetcode-week-10/"/>
    <url>/2021/leetcode-week-10/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h4 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a><a href="https://leetcode-cn.com/problems/couples-holding-hands/">765. 情侣牵手</a></h4><p>日期：<code>2021/02/14</code></p><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p><p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p><p><strong>示例 1:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> <span class="hljs-built_in">row</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>输出<span class="hljs-symbol">:</span> <span class="hljs-number">1</span><br>解释<span class="hljs-symbol">:</span> 我们只需要交换<span class="hljs-built_in">row</span>[<span class="hljs-number">1</span>]和<span class="hljs-built_in">row</span>[<span class="hljs-number">2</span>]的位置即可。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: row = [3, 2, 0, 1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 无需交换座位，所有的情侣都已经可以手牵手了。</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li><li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li></ol><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = row.length;<br>        <span class="hljs-keyword">int</span> len = n / <span class="hljs-number">2</span>;<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">int</span> left = row[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> right = row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>;<br>            uf.union(left, right);<br>        &#125;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            map.put(uf.find(i), map.getOrDefault(uf.find(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Integer val : map.values())&#123;<br>            ret += val - <span class="hljs-number">1</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br>        <span class="hljs-keyword">int</span> setNum;             <span class="hljs-comment">//连通图数量</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.setNum = n;<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            setNum--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="485-最大连续-1-的个数"><a href="#485-最大连续-1-的个数" class="headerlink" title="485. 最大连续 1 的个数"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续 1 的个数</a></h4><p>日期：<code>2021/02/15</code></p><p>给定一个二进制数组， 计算其中最大连续 1 的个数。</p><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,1,0,1,1,1]<br>输出：3<br>解释：开头的两位和最后的三位都是连续<span class="hljs-number"> 1 </span>，所以最大连续<span class="hljs-number"> 1 </span>的个数是 3.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入的数组只包含 <code>0</code> 和 <code>1</code> 。</li><li>输入数组的长度是正整数，且不超过 10,000。</li></ul><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br>                count++;<br>                ret = Math.max(ret, count);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></h4><p>日期：<code>2021/02/16</code></p><p>给定长度为 <code>2n</code> 的整数数组 <code>nums</code> ，你的任务是将这些数分成 <code>n</code> 对, 例如 <code>(a1, b1), (a2, b2), ..., (an, bn)</code> ，使得从 <code>1</code> 到 <code>n</code> 的 <code>min(ai, bi)</code> 总和最大。</p><p>返回该 <strong>最大总和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">4</span><br>解释：所有可能的分法（忽略元素顺序）为：<br><span class="hljs-number">1.</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span>, <span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span> -&gt;</span> min(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) + min(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br><span class="hljs-number">2.</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span>, <span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span> -&gt;</span> min(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) + min(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br><span class="hljs-number">3.</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span>, <span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span> -&gt;</span> min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) + min(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span><br>所以最大总和为 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：nums = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">9</span><br>解释：最优的分法为 (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>). <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) + <span class="hljs-built_in">min</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li><li><code>nums.length == 2 * n</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">arrayPairSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i = i + <span class="hljs-number">2</span>)&#123;<br>            ret += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></h4><p>日期：<code>2021/02/17</code></p><p>在MATLAB中，有一个非常有用的函数 <code>reshape</code>，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p><p>给出一个由二维数组表示的矩阵，以及两个正整数<code>r</code>和<code>c</code>，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong>行遍历顺序</strong>填充。</p><p>如果具有给定参数的<code>reshape</code>操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: <br>nums = <br><span class="hljs-string">[[1,2],</span><br><span class="hljs-string"> [3,4]]</span><br>r = <span class="hljs-number">1</span>, c = <span class="hljs-number">4</span><br>输出: <br><span class="hljs-string">[[1,2,3,4]]</span><br>解释:<br>行遍历nums的结果是 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]。新的矩阵是 <span class="hljs-number">1</span> * <span class="hljs-number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: <br>nums = <br><span class="hljs-string">[[1,2],</span><br><span class="hljs-string"> [3,4]]</span><br>r = <span class="hljs-number">2</span>, c = <span class="hljs-number">4</span><br>输出: <br><span class="hljs-string">[[1,2],</span><br><span class="hljs-string"> [3,4]]</span><br>解释:<br>没有办法将 <span class="hljs-number">2</span> * <span class="hljs-number">2</span> 矩阵转化为 <span class="hljs-number">2</span> * <span class="hljs-number">4</span> 矩阵。 所以输出原矩阵。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>给定矩阵的宽和高范围在 [1, 100]。</li><li>给定的 r 和 c 都是正数。</li></ol><h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixReshape(<span class="hljs-keyword">int</span>[][] nums, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        <span class="hljs-keyword">int</span> nRow = nums.length;<br>        <span class="hljs-keyword">int</span> nCol = nums[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(nRow * nCol != r * c)&#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nRow; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nCol; j++)&#123;<br>                <span class="hljs-keyword">int</span> number = i * nCol + j;<br>                <span class="hljs-keyword">int</span> newR = number / c;<br>                <span class="hljs-keyword">int</span> newC = number % c; <br>                ret[newR][newC] = nums[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="995-K-连续位的最小翻转次数"><a href="#995-K-连续位的最小翻转次数" class="headerlink" title="995. K 连续位的最小翻转次数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a></h4><p>日期：<code>2021/02/18</code></p><p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code> 中，一次 <em><code>K</code> 位翻转</em>包括选择一个长度为 <code>K</code> 的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为 <code>1</code>，而每个 <code>1</code> 更改为 <code>0</code>。</p><p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为 <code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], K = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">2</span><br>解释：先翻转 <span class="hljs-keyword">A</span>[<span class="hljs-number">0</span>]，然后翻转 <span class="hljs-keyword">A</span>[<span class="hljs-number">2</span>]。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,1,0]</span>, K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 <span class="hljs-comment">[1,1,1]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,1,1,0</span>], K = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>翻转 <span class="hljs-keyword">A</span>[<span class="hljs-number">0</span>],<span class="hljs-keyword">A</span>[<span class="hljs-number">1</span>],<span class="hljs-keyword">A</span>[<span class="hljs-number">2</span>]: <span class="hljs-keyword">A</span>变成 [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">0,1,1,0</span>]<br>翻转 <span class="hljs-keyword">A</span>[<span class="hljs-number">4</span>],<span class="hljs-keyword">A</span>[<span class="hljs-number">5</span>],<span class="hljs-keyword">A</span>[<span class="hljs-number">6</span>]: <span class="hljs-keyword">A</span>变成 [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,0,0,0</span>]<br>翻转 <span class="hljs-keyword">A</span>[<span class="hljs-number">5</span>],<span class="hljs-keyword">A</span>[<span class="hljs-number">6</span>],<span class="hljs-keyword">A</span>[<span class="hljs-number">7</span>]: <span class="hljs-keyword">A</span>变成 [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ol><h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = A.length;<br>        <span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, revCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            revCnt += diff[i];<br>            <span class="hljs-keyword">if</span> ((A[i] + revCnt) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + K &gt; n) &#123;<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                &#125;<br>                ++ans;<br>                ++revCnt;<br>                --diff[i + K];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h4><p>日期：<code>2021/02/19</code></p><p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], K = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">6</span><br>解释： <br>[<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0,1,1,1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>粗体数字从 <span class="hljs-number">0</span> 翻转到 <span class="hljs-number">1</span>，最长的子数组长度为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,0,1,1</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], K = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">10</span><br>解释：<br>[<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>粗体数字从 <span class="hljs-number">0</span> 翻转到 <span class="hljs-number">1</span>，最长的子数组长度为 <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 20000</code></li><li><code>0 &lt;= K &lt;= A.length</code></li><li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code> </li></ol><h5 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h5><p>使用滑动窗口并且记录下当前窗口内的<code>0</code>的数量。若数量小于等于<code>K</code>则仅右指针后移，数量大于K则左右指针整体移动。滑动到尾端时的窗口大小就是最大长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 窗口内0的数量</span><br>        <span class="hljs-keyword">int</span> n = A.length; <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左右指针</span><br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-comment">// 若右指针所值值为0，数量增加</span><br>            <span class="hljs-keyword">if</span>(A[right] == <span class="hljs-number">0</span>)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// 若窗口内0的数量大于K,移动左指针移除最左的值</span><br>            <span class="hljs-comment">// 若移除的至为0，数量减少</span><br>            <span class="hljs-keyword">if</span>(count &gt; K &amp;&amp; A[left++] == <span class="hljs-number">0</span>)&#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-comment">// 移动右指针</span><br>            right++;<br>        &#125;<br>        <span class="hljs-comment">// 因为right等于n，计算窗口大小时无需加一</span><br>        <span class="hljs-keyword">return</span> right - left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a><a href="https://leetcode-cn.com/problems/degree-of-an-array/">697. 数组的度</a></h4><p>日期：<code>2021/02/20</code></p><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1, 2, 2, 3, 1]</span><br>输出：2<br>解释：<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:<br><span class="hljs-selector-attr">[1, 2, 2, 3, 1]</span>, <span class="hljs-selector-attr">[1, 2, 2, 3]</span>, <span class="hljs-selector-attr">[2, 2, 3, 1]</span>, <span class="hljs-selector-attr">[1, 2, 2]</span>, <span class="hljs-selector-attr">[2, 2, 3]</span>, <span class="hljs-selector-attr">[2, 2]</span><br>最短连续子数组<span class="hljs-selector-attr">[2, 2]</span>的长度为2，所以返回2.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[1,2,2,3,1,4,2]</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums.length</code> 在1到 50,000 区间范围内。</li><li><code>nums[i]</code> 是一个在 0 到 49,999 范围内的整数。</li></ul><h5 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h5><p>只我们只需要寻找出现次数最多的数，然后计算其第一次出现位置到最后一次出现的位置的长度。所有长度取最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-comment">// 获取每个数字的出现次数、第一次出现位置、最后一次出现位置</span><br>        Map&lt;Integer, <span class="hljs-keyword">int</span>[]&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">int</span>[] count = map.getOrDefault(nums[i], <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, i, i&#125;);<br>            count[<span class="hljs-number">0</span>]++;<br>            count[<span class="hljs-number">2</span>] = i;<br>            map.put(nums[i], count);<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> minLength = n;<br>        <span class="hljs-comment">// 依次比较出现次数和子数组长度</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, <span class="hljs-keyword">int</span>[]&gt; entry : map.entrySet())&#123;<br>            <span class="hljs-keyword">int</span>[] val = entry.getValue();<br>            <span class="hljs-keyword">int</span> len = val[<span class="hljs-number">2</span>] - val[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 出现次数大于记录的最大值，长度设为当前长度</span><br>            <span class="hljs-keyword">if</span>(val[<span class="hljs-number">0</span>] &gt; maxCount)&#123;<br>                minLength = len;<br>                maxCount = val[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val[<span class="hljs-number">0</span>] == maxCount)&#123; <span class="hljs-comment">// 次数相同，取长度较小者</span><br>                minLength = Math.min(minLength, len);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第九周</title>
    <link href="/2021/leetcode-week-9/"/>
    <url>/2021/leetcode-week-9/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h2><p>日期：<code>2021/02/07</code></p><p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中任意的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [4,2,3]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [4,2,1]</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10 ^ 4</code></li><li><code>- 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] &gt; nums[i])&#123;<br>                count++;<br>                <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt; nums[i - <span class="hljs-number">2</span>]) &#123;<br>                    nums[i] = nums[i - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h2><p>日期：<code>2021/02/08</code></p><p>当 <code>A</code> 的子数组 <code>A[i], A[i+1], ..., A[j]</code> 满足下列条件时，我们称其为<em>湍流子数组</em>：</p><ul><li>若 <code>i &lt;= k &lt; j</code>，当 <code>k</code> 为奇数时， <code>A[k] &gt; A[k+1]</code>，且当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li><li><strong>或</strong> 若 <code>i &lt;= k &lt; j</code>，当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code> ，且当 <code>k</code> 为奇数时， <code>A[k] &lt; A[k+1]</code>。</li></ul><p>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 <code>A</code> 的最大湍流子数组的<strong>长度</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">9,4,2,10</span>,<span class="hljs-number">7,8,8,1</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">5</span><br>解释：(<span class="hljs-keyword">A</span>[<span class="hljs-number">1</span>] &gt; <span class="hljs-keyword">A</span>[<span class="hljs-number">2</span>] &lt; <span class="hljs-keyword">A</span>[<span class="hljs-number">3</span>] &gt; <span class="hljs-keyword">A</span>[<span class="hljs-number">4</span>] &lt; <span class="hljs-keyword">A</span>[<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[4,8,12,16]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[100]</span><br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 40000</code></li><li><code>0 &lt;= A[i] &lt;= 10^9</code></li></ol><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (left == right) &#123;<br>                <span class="hljs-keyword">if</span> (arr[left] == arr[left + <span class="hljs-number">1</span>]) &#123;<br>                    left++;<br>                &#125;<br>                right++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (arr[right - <span class="hljs-number">1</span>] &lt; arr[right] &amp;&amp; arr[right] &gt; arr[right + <span class="hljs-number">1</span>]) &#123;<br>                    right++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[right - <span class="hljs-number">1</span>] &gt; arr[right] &amp;&amp; arr[right] &lt; arr[right + <span class="hljs-number">1</span>]) &#123;<br>                    right++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left = right;<br>                &#125;<br>            &#125;<br>            ret = Math.max(ret, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a></h2><p>日期：<code>2021/02/09</code></p><p>给定一个正整数数组 <code>A</code>，如果 <code>A</code> 的某个子数组中不同整数的个数恰好为 <code>K</code>，则称 <code>A</code> 的这个连续、不一定不同的子数组为<em>好子数组</em>。</p><p>（例如，<code>[1,2,3,1,2]</code> 中有 <code>3</code> 个不同的整数：<code>1</code>，<code>2</code>，以及 <code>3</code>。）</p><p>返回 <code>A</code> 中<em>好子数组</em>的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-symbol">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-symbol">K</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">7</span><br>解释：恰好由 <span class="hljs-number">2</span> 个不同整数组成的子数组：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-symbol">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-symbol">K</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：恰好由 <span class="hljs-number">3</span> 个不同整数组成的子数组：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 20000</code></li><li><code>1 &lt;= A[i] &lt;= A.length</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ol><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraysWithKDistinct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> A</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> K</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 最多包含 K 个不同整数的子区间的个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">atMostKDistinct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = A.length;<br>        <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 里不同整数的个数</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>        <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>            <span class="hljs-keyword">if</span> (freq[A[right]] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>            freq[A[right]]++;<br>            right++;<br><br>            <span class="hljs-keyword">while</span> (count &gt; K) &#123;<br>                freq[A[left]]--;<br>                <span class="hljs-keyword">if</span> (freq[A[left]] == <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献</span><br>            res += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h2><p>日期：<code>2021/02/10</code></p><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入: <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出: True<br>解释: <span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入: <span class="hljs-built_in">s1</span>= <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidboaoo&quot;</span><br>输出: False<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s1.length(), m = s2.length();<br>        <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] cnt1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span>[] cnt2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ++cnt1[s1.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            ++cnt2[s2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Arrays.equals(cnt1, cnt2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt; m; ++i) &#123;<br>            ++cnt2[s2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --cnt2[s2.charAt(i - n) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (Arrays.equals(cnt1, cnt2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h2><p>日期：<code>2021/02/11</code></p><p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p><p>请实现 <code>KthLargest</code> 类：</p><ul><li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li><li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入：<br>[<span class="hljs-meta"><span class="hljs-meta-string">&quot;KthLargest&quot;</span>, <span class="hljs-meta-string">&quot;add&quot;</span>, <span class="hljs-meta-string">&quot;add&quot;</span>, <span class="hljs-meta-string">&quot;add&quot;</span>, <span class="hljs-meta-string">&quot;add&quot;</span>, <span class="hljs-meta-string">&quot;add&quot;</span></span>]<br>[<span class="hljs-meta">[3, [4, 5, 8, 2</span>]], [<span class="hljs-number">3</span>], [<span class="hljs-number">5</span>], [<span class="hljs-number">10</span>], [<span class="hljs-number">9</span>], [<span class="hljs-number">4</span>]]<br>输出：<br>[<span class="hljs-meta">null, 4, 5, 5, 8, 8</span>]<br><br>解释：<br>KthLargest kthLargest = <span class="hljs-keyword">new</span> KthLargest(<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]);<br>kthLargest.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);   <span class="hljs-comment">// return 4</span><br>kthLargest.<span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>);   <span class="hljs-comment">// return 5</span><br>kthLargest.<span class="hljs-keyword">add</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// return 5</span><br>kthLargest.<span class="hljs-keyword">add</span>(<span class="hljs-number">9</span>);   <span class="hljs-comment">// return 8</span><br>kthLargest.<span class="hljs-keyword">add</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// return 8</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 104</code></li><li><code>0 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>-104 &lt;= val &lt;= 104</code></li><li>最多调用 <code>add</code> 方法 <code>104</code> 次</li><li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> </span>&#123;<br>    PriorityQueue&lt;Integer&gt; pq;<br>    <span class="hljs-keyword">int</span> k;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>            add(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        pq.offer(val);<br>        <span class="hljs-keyword">if</span> (pq.size() &gt; k) &#123;<br>            pq.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> pq.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h2><p>日期：<code>2021/02/12</code></p><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 3</span><br><span class="hljs-section">输出: [1,3,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowIndex; i++)&#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; list.size(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                    temp.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    temp.add(list.get(j - <span class="hljs-number">1</span>) + list.get(j));<br>                &#125;<br>            &#125;<br>            temp.add(<span class="hljs-number">1</span>);<br>            list = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h2><p>日期：<code>2021/02/13</code></p><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入:<br><span class="hljs-string">[4,3,2,7,8,2,3,1]</span><br><br>输出:<br><span class="hljs-string">[5,6]</span><br></code></pre></td></tr></table></figure><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">int</span> x = (num - <span class="hljs-number">1</span>) % n;<br>            nums[x] += n;<br>        &#125;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= n) &#123;<br>                ret.add(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第八周</title>
    <link href="/2021/leetcode-week-8/"/>
    <url>/2021/leetcode-week-8/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="839-相似字符串组"><a href="#839-相似字符串组" class="headerlink" title="839. 相似字符串组"></a><a href="https://leetcode-cn.com/problems/similar-string-groups/">839. 相似字符串组</a></h2><p>日期：<code>2021/01/31</code></p><p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 <code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p><p>总之，它们通过相似性形成了两个关联组：<code>&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125;</code> 和 <code>&#123;&quot;star&quot;&#125;</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;tars&quot;</span>,<span class="hljs-string">&quot;rats&quot;</span>,<span class="hljs-string">&quot;arts&quot;</span>,<span class="hljs-string">&quot;star&quot;</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;omv&quot;</span>,<span class="hljs-string">&quot;ovm&quot;</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 300</code></li><li><code>1 &lt;= strs[i].length &lt;= 300</code></li><li><code>strs[i]</code> 只包含小写字母。</li><li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li></ul><p><strong>备注：</strong></p><p>   字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSimilarGroups</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(strs.length);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(isSimilar(strs[i], strs[j]))&#123;<br>                    uf.union(i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.setNum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimilar</span><span class="hljs-params">(String s1, String s2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(s1.charAt(i) != s2.charAt(i))&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br>        <span class="hljs-keyword">int</span> setNum;             <span class="hljs-comment">//连通图数量</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.setNum = n;<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            setNum--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="888-公平的糖果棒交换"><a href="#888-公平的糖果棒交换" class="headerlink" title="888. 公平的糖果棒交换"></a><a href="https://leetcode-cn.com/problems/fair-candy-swap/">888. 公平的糖果棒交换</a></h2><p>日期：<code>2021/02/01</code></p><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em></p><p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。</p><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,1]</span>, B = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,2]</span>, B = <span class="hljs-comment">[2,3]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[2]</span>, B = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,2,5]</span>, B = <span class="hljs-comment">[2,4]</span><br>输出：<span class="hljs-comment">[5,4]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= B.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 100000</code></li><li><code>1 &lt;= B[i] &lt;= 100000</code></li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在。</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] fairCandySwap(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B) &#123;<br>        <span class="hljs-keyword">int</span>[] ret = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">int</span> SumA = <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : A)&#123;<br>            SumA += a;<br>            set.add(a);<br>        &#125;<br>        <span class="hljs-keyword">int</span> SumB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b : B)&#123;<br>            SumB += b;<br>        &#125;<br>        <span class="hljs-keyword">int</span> diff = (SumA - SumB) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b : B)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(b + diff))&#123;<br>                ret[<span class="hljs-number">0</span>] = b + diff;<br>                ret[<span class="hljs-number">1</span>] = b;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h2><p>日期：<code>2021/02/02</code></p><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意：</strong>字符串长度 和 <em>k</em> 不会超过 104。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ABAB&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;AABABBA&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 <span class="hljs-string">&quot;AABBBBA&quot;</span>。<br>子串 <span class="hljs-string">&quot;BBBB&quot;</span> 有最长重复字母, 答案为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            num[s.charAt(right) - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            maxn = Math.max(maxn, num[s.charAt(right) - <span class="hljs-string">&#x27;A&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - maxn &gt; k) &#123;<br>                num[s.charAt(left) - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480. 滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></h2><p>日期：<code>2021/02/03</code></p><p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><p>例如：</p><ul><li><code>[2,3,4]</code>，中位数是 <code>3</code></li><li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li></ul><p>给你一个数组 <em>nums</em>，有一个长度为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p><p><strong>示例：</strong></p><p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">窗口位置                      中位数<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       1<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7      <span class="hljs-string">-1</span><br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7      <span class="hljs-string">-1</span><br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       3<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      6<br></code></pre></td></tr></table></figure><p> 因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p><p><strong>提示：</strong></p><ul><li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于等于输入的非空数组的元素个数。</li><li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] medianSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">double</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + k - <span class="hljs-number">1</span> &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++)&#123;<br>                window[j] = nums[i + j];<br>            &#125;<br>            Arrays.sort(window);<br>            ret[i] = window[k / <span class="hljs-number">2</span>]  / <span class="hljs-number">2.0</span> + window[(k - <span class="hljs-number">1</span>)/ <span class="hljs-number">2</span>]  / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h2><p>日期：<code>2021/02/04</code></p><p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p><p><strong>示例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[1,12,<span class="hljs-string">-5</span>,<span class="hljs-string">-6</span>,50,3], k = 4<br>输出：12.75<br>解释：最大平均数 (12<span class="hljs-string">-5</span><span class="hljs-string">-6</span><span class="hljs-string">+50</span>)/4 = 51/4 = 12.75<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000。</li><li>所给数据范围 [-10,000，10,000]。</li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> n = k / <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">double</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> avg = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            avg += nums[i] / n;<br>        &#125;<br>        ret = avg;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++)&#123;<br>            avg -= nums[i - k] / n;<br>            avg += nums[i] / n;<br>            ret = ret &gt; avg ? ret : avg;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></h2><p>日期：<code>2021/02/05</code></p><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p><p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;bcdf&quot;</span>, <span class="hljs-attr">cost</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：s 中的 <span class="hljs-string">&quot;abc&quot;</span> 可以变为 <span class="hljs-string">&quot;bcd&quot;</span>。开销为 <span class="hljs-number">3</span>，所以最大长度为 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;cdef&quot;</span>, <span class="hljs-attr">cost</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">1</span><br>解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 <span class="hljs-number">2</span>。因此，最大长度为 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;acde&quot;</span>, <span class="hljs-attr">cost</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法作出任何改动，所以最大长度为 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li><li><code>0 &lt;= maxCost &lt;= 10^6</code></li><li><code>s</code> 和 <code>t</code> 都只含小写英文字母。</li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-keyword">int</span> maxCost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">int</span>[] costs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            costs[i] = Math.abs(s.charAt(i) - t.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">int</span> totalCost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            totalCost += costs[right];<br>            <span class="hljs-keyword">if</span>(totalCost &gt; maxCost)&#123;<br>                totalCost -= costs[left];<br>                left++;<br>            &#125;<br>            ret = Math.max(ret, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></h2><p>日期：<code>2021/02/06</code></p><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是<span class="hljs-number"> 1 </span>。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">cardPoints</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">cardPoints</span> = [<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">55</span><br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">cardPoints</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="hljs-number">1</span> 。 <br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cardPoints = [<span class="hljs-number">1,79,80,1</span>,<span class="hljs-number">1,1,200,1</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">202</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li><li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= cardPoints.length</code></li></ul><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = cardPoints.length;<br>        <span class="hljs-keyword">int</span> minLength = n - k;<br>        <span class="hljs-keyword">int</span> sum = Arrays.stream(cardPoints).sum();<br>        <span class="hljs-keyword">int</span> minSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; minLength; i++)&#123;<br>            minSum += cardPoints[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> tempSum = minSum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = minLength; i &lt; n ;i ++)&#123;<br>            tempSum +=  cardPoints[i]- cardPoints[i - minLength];<br>            minSum = Math.min(tempSum, minSum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - minSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第七周</title>
    <link href="/2021/leetcode-week-7/"/>
    <url>/2021/leetcode-week-7/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h2><p>日期：<code>2021/01/24</code></p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span><br>输出：3<br>解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。<br>尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span><br>输出：1<br>解释：最长连续递增序列是 <span class="hljs-comment">[2]</span>, 长度为1。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>                start = i;<br>            &#125;<br>            ans = Math.max(ans, i - start + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="959-由斜杠划分区域"><a href="#959-由斜杠划分区域" class="headerlink" title="959. 由斜杠划分区域"></a><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></h2><p>日期：<code>2021/01/25</code></p><p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>&quot;\\&quot;</code> 表示。）。</p><p>返回区域的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入：<br>[<span class="hljs-meta"></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot; /&quot;</span>,</span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;/ &quot;</span></span><br><span class="hljs-meta"></span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">2</span>x2 网格如下：<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入：<br>[<span class="hljs-meta"></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot; /&quot;</span>,</span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;  &quot;</span></span><br><span class="hljs-meta"></span>]<br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">2</span>x2 网格如下：<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lsl">输入：<br>[<br>  <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>/&quot;</span>,<br>  <span class="hljs-string">&quot;/<span class="hljs-subst">\\</span>&quot;</span><br>]<br>输出：<span class="hljs-number">4</span><br>解释：（回想一下，因为 \ 字符是转义的，所以 <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>/&quot;</span> 表示 \/，而 <span class="hljs-string">&quot;/<span class="hljs-subst">\\</span>&quot;</span> 表示 /\。）<br><span class="hljs-number">2</span>x2 网格如下：<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lsl">输入：<br>[<br>  <span class="hljs-string">&quot;/<span class="hljs-subst">\\</span>&quot;</span>,<br>  <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>/&quot;</span><br>]<br>输出：<span class="hljs-number">5</span><br>解释：（回想一下，因为 \ 字符是转义的，所以 <span class="hljs-string">&quot;/<span class="hljs-subst">\\</span>&quot;</span> 表示 /\，而 <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>/&quot;</span> 表示 \/。）<br><span class="hljs-number">2</span>x2 网格如下：<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入：<br>[<span class="hljs-meta"></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;//&quot;</span>,</span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;/ &quot;</span></span><br><span class="hljs-meta"></span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">2</span>x2 网格如下：<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= grid.length == grid[0].length &lt;= 30</code></li><li><code>grid[i][j]</code> 是 <code>&#39;/&#39;</code>、<code>&#39;\&#39;</code>、或 <code>&#39; &#39;</code>。</li></ol><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">regionsBySlashes</span><span class="hljs-params">(String[] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> N = grid.length;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-number">4</span> * N * N;<br><br>        UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(size);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">char</span>[] row = grid[i].toCharArray();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>                <span class="hljs-comment">// 二维网格转换为一维表格，index 表示将单元格拆分成 4 个小三角形以后，编号为 0 的小三角形的在并查集中的下标</span><br>                <span class="hljs-keyword">int</span> index = <span class="hljs-number">4</span> * (i * N + j);<br>                <span class="hljs-keyword">char</span> c = row[j];<br>                <span class="hljs-comment">// 单元格内合并</span><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 合并 0、3，合并 1、2</span><br>                    unionFind.union(index, index + <span class="hljs-number">3</span>);<br>                    unionFind.union(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 合并 0、1，合并 2、3</span><br>                    unionFind.union(index, index + <span class="hljs-number">1</span>);<br>                    unionFind.union(index + <span class="hljs-number">2</span>, index + <span class="hljs-number">3</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    unionFind.union(index, index + <span class="hljs-number">1</span>);<br>                    unionFind.union(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span>);<br>                    unionFind.union(index + <span class="hljs-number">2</span>, index + <span class="hljs-number">3</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 单元格间合并</span><br>                <span class="hljs-comment">// 向右合并：1（当前）、3（右一列）</span><br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; N) &#123;<br>                    unionFind.union(index + <span class="hljs-number">1</span>, <span class="hljs-number">4</span> * (i * N + j + <span class="hljs-number">1</span>) + <span class="hljs-number">3</span>);<br>                &#125;<br>                <span class="hljs-comment">// 向下合并：2（当前）、0（下一行）</span><br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N) &#123;<br>                    unionFind.union(index + <span class="hljs-number">2</span>, <span class="hljs-number">4</span> * ((i + <span class="hljs-number">1</span>) * N + j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> unionFind.getCount();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.count = n;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                parent[i] = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (x != parent[x]) &#123;<br>                parent[x] = parent[parent[x]];<br>                x = parent[x];<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            parent[rootX] = rootY;<br>            count--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1128-等价多米诺骨牌对的数量"><a href="#1128-等价多米诺骨牌对的数量" class="headerlink" title="1128. 等价多米诺骨牌对的数量"></a><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/">1128. 等价多米诺骨牌对的数量</a></h2><p>日期：<code>2021/01/26</code></p><p>给你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。</p><p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p><p>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a==c</code> 且 <code>b==d</code>，或是 <code>a==d</code> 且 <code>b==c</code>。</p><p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：dominoes = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>]</span><br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dominoes.length &lt;= 40000</code></li><li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numEquivDominoPairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dominoes)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] domino : dominoes) &#123;<br>            <span class="hljs-keyword">int</span> val = domino[<span class="hljs-number">0</span>] &lt; domino[<span class="hljs-number">1</span>] ? domino[<span class="hljs-number">0</span>] * <span class="hljs-number">10</span> + domino[<span class="hljs-number">1</span>] : domino[<span class="hljs-number">1</span>] * <span class="hljs-number">10</span> + domino[<span class="hljs-number">0</span>];<br>            ret += num[val];<br>            num[val]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1579-保证图可完全遍历"><a href="#1579-保证图可完全遍历" class="headerlink" title="1579. 保证图可完全遍历"></a><a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">1579. 保证图可完全遍历</a></h2><p>日期：<code>2021/01/27</code></p><p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：</p><ul><li>类型 1：只能由 Alice 遍历。</li><li>类型 2：只能由 Bob 遍历。</li><li>类型 3：Alice 和 Bob 都可以遍历。</li></ul><p>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [typei, ui, vi]</code> 表示节点 <code>ui</code> 和 <code>vi</code> 之间存在类型为 <code>typei</code> 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p><p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex1.png" alt="img"></strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, edges = <span class="hljs-comment">[<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,3]</span>,<span class="hljs-comment">[1,1,3]</span>,<span class="hljs-comment">[1,2,4]</span>,<span class="hljs-comment">[1,1,2]</span>,<span class="hljs-comment">[2,3,4]</span>]</span><br>输出：2<br>解释：如果删除 <span class="hljs-comment">[1,1,2]</span> 和 <span class="hljs-comment">[1,1,3]</span> 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex2.png" alt="img"></strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, edges = <span class="hljs-comment">[<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,3]</span>,<span class="hljs-comment">[1,1,4]</span>,<span class="hljs-comment">[2,1,4]</span>]</span><br>输出：0<br>解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex3.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, edges = <span class="hljs-string">[[3,2,3],[1,1,2],[2,3,4]]</span><br>输出：<span class="hljs-number">-1</span><br>解释：在当前图中，Alice 无法从其他节点到达节点 <span class="hljs-number">4</span> 。类似地，Bob 也不能达到节点 <span class="hljs-number">1</span> 。因此，图无法完全遍历。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li><li><code>edges[i].length == 3</code></li><li><code>1 &lt;= edges[i][0] &lt;= 3</code></li><li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li><li>所有元组 <code>(typei, ui, vi)</code> 互不相同</li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxNumEdgesToRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        UnionFind ufAlice = <span class="hljs-keyword">new</span> UnionFind(n + <span class="hljs-number">1</span>);<br>        UnionFind ufBob = <span class="hljs-keyword">new</span> UnionFind(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            <span class="hljs-keyword">if</span>(edge[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">boolean</span> flagAlice = ufAlice.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>                <span class="hljs-keyword">boolean</span> flagBob = ufBob.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>                <span class="hljs-keyword">if</span>(!flagAlice &amp;&amp; !flagBob)&#123;<br>                    ret++;<br>                &#125;<br>            &#125;<br>        &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            <span class="hljs-keyword">if</span>(edge[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; !ufAlice.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]))&#123;<br>                ret++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(edge[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> &amp;&amp; !ufBob.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]))&#123;<br>                ret++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ufAlice.setNum &gt; <span class="hljs-number">2</span> || ufBob.setNum &gt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br>        <span class="hljs-keyword">int</span> setNum;             <span class="hljs-comment">//连通图数量</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.setNum = n;<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            setNum--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心索引</a></h2><p>日期：`2021/01/28</p><p>给你一个整数数组 <code>nums</code>，请编写一个能够返回数组 <strong>“中心索引”</strong> 的方法。</p><p>数组 <strong>中心索引</strong> 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，返回 <code>-1</code> 。如果数组有多个中心索引，应该返回最靠近左边的那一个。</p><p><strong>注意：</strong>中心索引可能出现在数组的两端。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心索引是<span class="hljs-number"> 3 </span>。<br>左侧数之和 (1 +<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 3 </span>= 11)，<br>右侧数之和 (5 +<span class="hljs-number"> 6 </span>= 11) ，二者相等。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1, 2, 3]</span><br><span class="hljs-string">输出：-1</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">数组中不存在满足此条件的中心索引。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2, 1, -1]<br>输出：0<br>解释：<br>中心索引是<span class="hljs-number"> 0 </span>。<br>索引<span class="hljs-number"> 0 </span>左侧不存在元素，视作和为<span class="hljs-number"> 0 </span>；<br>右侧数之和为<span class="hljs-number"> 1 </span>+ (-1) =<span class="hljs-number"> 0 </span>，二者相等。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> num = nums[i];<br>            <span class="hljs-keyword">if</span>((left * <span class="hljs-number">2</span> + num) == sum)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            left += num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h2><p>日期：<code>2021/01/29</code></p><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：heights = <span class="hljs-comment">[<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[3,8,2]</span>,<span class="hljs-comment">[5,3,5]</span>]</span><br>输出：2<br>解释：路径 <span class="hljs-comment">[1,3,5,3,5]</span> 连续格子的差值绝对值最大为 2 。<br>这条路径比路径 <span class="hljs-comment">[1,2,2,2,5]</span> 更优，因为另一条路径差值最大值为 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：heights = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[3,8,4]</span>,<span class="hljs-comment">[5,3,5]</span>]</span><br>输出：1<br>解释：路径 <span class="hljs-comment">[1,2,3,4,5]</span> 的相邻格子差值绝对值最大为 1 ，比路径 <span class="hljs-comment">[1,3,5,3,5]</span> 更优。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：heights = <span class="hljs-comment">[<span class="hljs-comment">[1,2,1,1,1]</span>,<span class="hljs-comment">[1,2,1,2,1]</span>,<span class="hljs-comment">[1,2,1,2,1]</span>,<span class="hljs-comment">[1,2,1,2,1]</span>,<span class="hljs-comment">[1,1,1,2,1]</span>]</span><br>输出：0<br>解释：上图所示路径不需要消耗任何体力。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == heights.length</code></li><li><code>columns == heights[i].length</code></li><li><code>1 &lt;= rows, columns &lt;= 100</code></li><li><code>1 &lt;= heights[i][j] &lt;= 106</code></li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = heights.length;<br>        <span class="hljs-keyword">int</span> n = heights[<span class="hljs-number">0</span>].length;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">int</span> id = i * n + j;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">int</span> val = Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j]);<br>                    <span class="hljs-keyword">int</span>[] edge = &#123;id - n, id, val&#125;;<br>                    edges.add(edge);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">int</span> val = Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">int</span>[] edge = &#123;id - <span class="hljs-number">1</span>, id, val&#125;;<br>                    edges.add(edge);<br>                &#125;<br>            &#125;<br>        &#125;<br>        Collections.sort(edges, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] edge1, <span class="hljs-keyword">int</span>[] edge2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> edge1[<span class="hljs-number">2</span>] - edge2[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;);<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(h * n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(uf.find(<span class="hljs-number">0</span>) == uf.find(h * n - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> edge[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br>        <span class="hljs-keyword">int</span> setNum;             <span class="hljs-comment">//连通图数量</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.setNum = n;<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            setNum--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="778-水位上升的泳池中游泳"><a href="#778-水位上升的泳池中游泳" class="headerlink" title="778. 水位上升的泳池中游泳"></a><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></h2><p>日期：<code>2021/01/30</code></p><p>在一个 N x N 的坐标方格 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示在位置 <code>(i,j)</code> 的平台高度。</p><p>现在开始下雨了。当时间为 <code>t</code> 时，此时雨水导致水池中任意位置的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 <code>(N-1, N-1)</code>？</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: <span class="hljs-string">[[0,2],[1,3]]</span><br>输出: <span class="hljs-number">3</span><br>解释:<br>时间为<span class="hljs-number">0</span>时，你位于坐标方格的位置为 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)。<br>此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 <span class="hljs-number">0</span> 时的水位。<br><br>等时间到达 <span class="hljs-number">3</span> 时，你才可以游向平台 (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>). 因为此时的水位是 <span class="hljs-number">3</span>，坐标方格中的平台没有比水位 <span class="hljs-number">3</span> 更高的，所以你可以游向坐标方格中的任意位置<br></code></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br>输出: 16<br>解释:<br><span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>24<span class="hljs-number"> 23 </span>22<span class="hljs-number"> 21 </span> 5<br>12<span class="hljs-number"> 13 </span>14<span class="hljs-number"> 15 </span>16<br>11<span class="hljs-number"> 17 </span>18<span class="hljs-number"> 19 </span>20<br>10 <span class="hljs-number"> 9 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span> 6<br><br>最终的路线用加粗进行了标记。<br>我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><code>2 &lt;= N &lt;= 50</code>.</li><li><code>grid[i][j]</code> 是 <code>[0, ..., N*N - 1]</code> 的排列。</li></ol><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">swimInWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = grid.length;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; points = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">int</span> val = grid[i][j];<br>                <span class="hljs-keyword">int</span>[] point = &#123;i, j, val&#125;;<br>                points.add(point);<br>            &#125;<br>        &#125;<br>        Collections.sort(points, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] point1, <span class="hljs-keyword">int</span>[] point2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> point1[<span class="hljs-number">2</span>] - point2[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;);<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n * n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] point : points)&#123;<br>            <span class="hljs-keyword">int</span> i = point[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> j = point[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> val = point[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">int</span> id = i * n + j;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] &lt;= val)&#123;<br>                uf.union(id - n, id);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] &lt;= val)&#123;<br>                uf.union(id - <span class="hljs-number">1</span>, id);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; n - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] &lt;= val)&#123;<br>                uf.union(id + n, id);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j &lt; n - <span class="hljs-number">1</span> &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] &lt;= val)&#123;<br>                uf.union(id + <span class="hljs-number">1</span>, id);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(uf.find(<span class="hljs-number">0</span>) == uf.find(n * n - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br>        <span class="hljs-keyword">int</span> setNum;             <span class="hljs-comment">//连通图数量</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.setNum = n;<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            setNum--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo中使用Mermaid生成流程图</title>
    <link href="/2021/mermaid/"/>
    <url>/2021/mermaid/</url>
    
    <content type="html"><![CDATA[<p>Mermaid是一个基于Javascript的Markdown图表绘制工具。你可以通过Mermaid来快速创建和维护图表。</p><a id="more"></a><h3 id="1-、安装Mermaid"><a href="#1-、安装Mermaid" class="headerlink" title="1 、安装Mermaid"></a>1 、安装Mermaid</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-filter-mermaid-diagrams<br></code></pre></td></tr></table></figure><h4 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h4><p>我这里是Fluid的配置</p><p>当需要使用 <a href="http://mermaid-js.github.io/mermaid/#/">Mermaid</a>渲染流程图时，可手动开启本功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">mermaid:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">options:</span><br></code></pre></td></tr></table></figure><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter </a>里指定 <code>mermaid: true</code> 才会在文章页启动流程图渲染，以便在页面不包含流程图时提高加载速度。</p><p><code>options</code>: 官方 API 的配置项，具体可见 <a href="http://mermaid-js.github.io/mermaid/#/mermaidAPI">mermaidAPI.js</a></p><h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>在代码块中标注为Mermaid即可启用</p><h3 id="2、-图标示例"><a href="#2、-图标示例" class="headerlink" title="2、 图标示例"></a>2、 图标示例</h3><p><a href="https://mermaid-js.github.io/mermaid/#/">官方介绍 - 英文</a></p><h4 id="图表类型"><a href="#图表类型" class="headerlink" title="图表类型"></a>图表类型</h4><ul><li>流程图</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">graph LR<br>    A <span class="hljs-comment">--- B</span><br></code></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>    A --- B<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Mermaid</tag>
      
      <tag>流程图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第六周</title>
    <link href="/2021/leetcode-week-6/"/>
    <url>/2021/leetcode-week-6/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. 缀点成线</a></h2><p>日期：<code>2021/01/17</code></p><p>在一个 XY 坐标系中有一些点，我们用数组 <code>coordinates</code> 来分别记录它们的坐标，其中 <code>coordinates[i] = [x, y]</code> 表示横坐标为 <code>x</code>、纵坐标为 <code>y</code> 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 <code>true</code>，否则请返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：coordinates = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[6,7]</span>]</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg" alt="img"></strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：coordinates = <span class="hljs-comment">[<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[7,7]</span>]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= coordinates.length &lt;= 1000</code></li><li><code>coordinates[i].length == 2</code></li><li><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></li><li><code>coordinates</code> 中不含重复的点</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每个点与第一个点计算斜率是否相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkStraightLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] coordinates)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> y1 = coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - coordinates[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> x1 = coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - coordinates[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; coordinates.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> y2 = coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - coordinates[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> x2 = coordinates[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - coordinates[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span>(y1 * x2 != y2 * x1)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721. 账户合并"></a><a href="https://leetcode-cn.com/problems/accounts-merge/">721. 账户合并</a></h2><p>日期：<code>2021/01/18</code></p><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称 (name)</em>，其余元素是 <em>emails</em> 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按字符 ASCII 顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>accounts = [[<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>, <span class="hljs-string">&quot;john00@mail.com&quot;</span>], [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnnybravo@mail.com&quot;</span>], [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>, <span class="hljs-string">&quot;john_newyork@mail.com&quot;</span>], [<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&quot;mary@mail.com&quot;</span>]]<br>输出：<br>[[<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&#x27;john00@mail.com&#x27;</span>, <span class="hljs-string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="hljs-string">&#x27;johnsmith@mail.com&#x27;</span>],  [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnnybravo@mail.com&quot;</span>], [<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&quot;mary@mail.com&quot;</span>]]<br>解释：<br>第一个和第三个 <span class="hljs-symbol">John</span> 是同一个人，因为他们有共同的邮箱地址 <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>。 <br>第二个 <span class="hljs-symbol">John</span> 和 <span class="hljs-symbol">Mary</span> 是不同的人，因为他们的邮箱地址没有被其他帐户使用。<br>可以以任何顺序返回这些列表，例如答案 [[<span class="hljs-string">&#x27;Mary&#x27;</span>，<span class="hljs-string">&#x27;mary@mail.com&#x27;</span>]，[<span class="hljs-string">&#x27;John&#x27;</span>，<span class="hljs-string">&#x27;johnnybravo@mail.com&#x27;</span>]，<br>[<span class="hljs-string">&#x27;John&#x27;</span>，<span class="hljs-string">&#x27;john00@mail.com&#x27;</span>，<span class="hljs-string">&#x27;john_newyork@mail.com&#x27;</span>，<span class="hljs-string">&#x27;johnsmith@mail.com&#x27;</span>]] 也是正确的。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>accounts</code>的长度将在<code>[1，1000]</code>的范围内。</li><li><code>accounts[i]</code>的长度将在<code>[1，10]</code>的范围内。</li><li><code>accounts[i][j]</code>的长度将在<code>[1，30]</code>的范围内。</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>使用并查集，将同一个账户下的所有电子邮件进行<code>union</code>操作。若不同账户之间有相同电子邮件则会被合并在一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;<br>        Map&lt;String, Integer&gt; emailIndex= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;String, String&gt; emailName= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 保存邮件对应的Index和Name</span><br>        <span class="hljs-keyword">for</span>(List&lt;String&gt; list : accounts)&#123;<br>            String name = list.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; list.size(); i++)&#123;<br>                String email = list.get(i);<br>                <span class="hljs-keyword">if</span>(!emailIndex.containsKey(email))&#123;<br>                    emailIndex.put(email, count++);<br>                    emailName.put(email, name);<br>                &#125;<br>            &#125;<br>        &#125;<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(count);<br>        <span class="hljs-comment">// 对每个账户下的所有电子邮件进行union操作</span><br>        <span class="hljs-comment">// 若不同账户有相同电子邮件则会被合并</span><br>        <span class="hljs-keyword">for</span>(List&lt;String&gt; list : accounts)&#123;<br>            String email1 = list.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> index1 = emailIndex.get(email1);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; list.size(); i++)&#123;<br>                String email2 = list.get(i);<br>                <span class="hljs-keyword">int</span> index2 = emailIndex.get(email2);<br>                uf.union(index1, index2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将合并后同一账户的电子邮件放到同一个List里面</span><br>        Map&lt;Integer, List&lt;String&gt;&gt; emailList= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String email : emailIndex.keySet())&#123;<br>            <span class="hljs-keyword">int</span> root = uf.find(emailIndex.get(email));<br>            <span class="hljs-keyword">if</span>(emailList.containsKey(root))&#123;<br>                List&lt;String&gt; l = emailList.get(root);<br>                l.add(email);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                List&lt;String&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>                l.add(email);<br>                emailList.put(root, l);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 获取账户的名字，并构造为要求的返回格式</span><br>        List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(List&lt;String&gt; list : emailList.values())&#123;<br>            Collections.sort(list);<br>            List&lt;String&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>            String name = emailName.get(list.get(<span class="hljs-number">0</span>));<br>            l.add(name);<br>            l.addAll(list);<br>            ans.add(l);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h2><p>日期：<code>2021/01/19</code></p><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p><p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/26/d.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,10]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[7,0]</span>]</span><br>输出：20<br>解释：<br><br>我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。<br>注意到任意两个点之间只有唯一一条路径互相到达。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[3,12],[-2,5],[-4,1]]</span><br>输出：<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[-1,1]</span>]</span><br>输出：4<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：points = [[-<span class="hljs-number">1000000</span>,-<span class="hljs-number">1000000</span>],[<span class="hljs-number">1000000</span>,<span class="hljs-number">1000000</span>]]<br>输出：<span class="hljs-number">4000000</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[0,0]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点 <code>(xi, yi)</code> 两两不同。</li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = points.length;<br>        List&lt;Edge&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 列出所有可能的连接边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">int</span> length = getLength(points[i], points[j]);<br>                edges.add(<span class="hljs-keyword">new</span> Edge(i, j, length));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将边按照曼哈顿距离升序排序</span><br>        Collections.sort(edges,<span class="hljs-keyword">new</span> Comparator&lt;Edge&gt;()&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Edge arg0, Edge arg1)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> arg0.length - arg1.length;<br>            &#125;<br>        &#125;);<br>        <br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//已连接点的数量</span><br>        <span class="hljs-comment">// 依次添加边,知道所有点都连接在一起</span><br>        <span class="hljs-keyword">for</span>(Edge edge : edges)&#123;<br>            <span class="hljs-keyword">if</span>(uf.union(edge.x, edge.y))&#123;<br>                ans += edge.length;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count == n)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取曼哈顿距离</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] point1, <span class="hljs-keyword">int</span>[] point2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> absX = Math.abs(point1[<span class="hljs-number">0</span>] - point2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> absY = Math.abs(point1[<span class="hljs-number">1</span>] - point2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> absX + absY;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span></span>&#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-keyword">int</span> y;<br>        <span class="hljs-keyword">int</span> length;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> length)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.x = x;<br>            <span class="hljs-keyword">this</span>.y = y;<br>            <span class="hljs-keyword">this</span>.length = length;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a></h2><p>日期：<code>2021/01/20</code></p><p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3]</span><br><span class="hljs-string">输出：6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出：<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>]<br>输出：<span class="hljs-string">-6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>三个数的最大乘积有两种情况：第一种情况是全最大的三个正数相乘。第二种情况是存在负数时，最小的两个负数与最大的正数相乘。分别计算这两种情况的乘积然后取其中较大者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> n = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans1 = nums[n] * nums[n - <span class="hljs-number">1</span>] * nums[n - <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> ans2 = nums[n] * nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> ans1 &gt; ans2 ? ans1 : ans2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1489-找到最小生成树里的关键边和伪关键边"><a href="#1489-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. 找到最小生成树里的关键边和伪关键边"></a><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">1489. 找到最小生成树里的关键边和伪关键边</a></h2><p>日期：<code>2021/01/21</code></p><p>给你一个 <code>n</code> 个点的带权无向连通图，节点编号为 <code>0</code> 到 <code>n-1</code> ，同时还有一个数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi, weighti]</code> 表示在 <code>fromi</code> 和 <code>toi</code> 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p><p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p><p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 5, edges = <span class="hljs-comment">[<span class="hljs-comment">[0,1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[2,3,2]</span>,<span class="hljs-comment">[0,3,2]</span>,<span class="hljs-comment">[0,4,3]</span>,<span class="hljs-comment">[3,4,3]</span>,<span class="hljs-comment">[1,4,6]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[2,3,4,5]</span>]</span><br>解释：上图描述了给定图。<br>下图是所有的最小生成树。<br><br>注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。<br>边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。<br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, edges = <span class="hljs-string">[[0,1,1],[1,2,1],[2,3,1],[0,3,1]]</span><br>输出：<span class="hljs-string">[[],[0,1,2,3]]</span><br>解释：可以观察到 <span class="hljs-number">4</span> 条边都有相同的权值，任选它们中的 <span class="hljs-number">3</span> 条可以形成一棵 MST 。所以 <span class="hljs-number">4</span> 条边都是伪关键边。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 3</code></li><li><code>0 &lt;= fromi &lt; toi &lt; n</code></li><li><code>1 &lt;= weighti &lt;= 1000</code></li><li>所有 <code>(fromi, toi)</code> 数对都是互不相同的。</li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findCriticalAndPseudoCriticalEdges(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges) &#123;<br>        <span class="hljs-keyword">int</span> m = edges.length;<br>        <span class="hljs-keyword">int</span>[][] newEdges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j) &#123;<br>                newEdges[i][j] = edges[i][j];<br>            &#125;<br>            newEdges[i][<span class="hljs-number">3</span>] = i;<br>        &#125;<br>        Arrays.sort(newEdges, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] u, <span class="hljs-keyword">int</span>[] v)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> u[<span class="hljs-number">2</span>] - v[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 计算 value</span><br>        UnionFind ufStd = <span class="hljs-keyword">new</span> UnionFind(n);<br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ufStd.unite(newEdges[i][<span class="hljs-number">0</span>], newEdges[i][<span class="hljs-number">1</span>])) &#123;<br>                value += newEdges[i][<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-comment">// 判断是否是关键边</span><br>            UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);<br>            <span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; uf.unite(newEdges[j][<span class="hljs-number">0</span>], newEdges[j][<span class="hljs-number">1</span>])) &#123;<br>                    v += newEdges[j][<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (uf.setCount != <span class="hljs-number">1</span> || (uf.setCount == <span class="hljs-number">1</span> &amp;&amp; v &gt; value)) &#123;<br>                ans.get(<span class="hljs-number">0</span>).add(newEdges[i][<span class="hljs-number">3</span>]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断是否是伪关键边</span><br>            uf = <span class="hljs-keyword">new</span> UnionFind(n);<br>            uf.unite(newEdges[i][<span class="hljs-number">0</span>], newEdges[i][<span class="hljs-number">1</span>]);<br>            v = newEdges[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; uf.unite(newEdges[j][<span class="hljs-number">0</span>], newEdges[j][<span class="hljs-number">1</span>])) &#123;<br>                    v += newEdges[j][<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (v == value) &#123;<br>                ans.get(<span class="hljs-number">1</span>).add(newEdges[i][<span class="hljs-number">3</span>]);<br>            &#125;<br>        &#125;<br>      <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集模板</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-keyword">int</span>[] size;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-comment">// 当前连通分量数目</span><br>    <span class="hljs-keyword">int</span> setCount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        <span class="hljs-keyword">this</span>.setCount = n;<br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(size, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> parent[x] == x ? x : (parent[x] = findset(parent[x]));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        x = findset(x);<br>        y = findset(y);<br>        <span class="hljs-keyword">if</span> (x == y) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y]) &#123;<br>            <span class="hljs-keyword">int</span> temp = x;<br>            x = y;<br>            y = temp;<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        --setCount;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        x = findset(x);<br>        y = findset(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989. 数组形式的整数加法"></a><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/">989. 数组形式的整数加法</a></h2><p>日期：<code>2021/01/22</code></p><p>对于非负整数 <code>X</code> 而言，<em><code>X</code></em> 的<em>数组形式</em>是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为 <code>[1,2,3,1]</code>。</p><p>给定非负整数 <code>X</code> 的数组形式 <code>A</code>，返回整数 <code>X+K</code> 的数组形式。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">1,2,0,0</span>], K = <span class="hljs-number">34</span><br>输出：[<span class="hljs-number">1,2,3,4</span>]<br>解释：<span class="hljs-number">1200</span> + <span class="hljs-number">34</span> = <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[2,7,4]</span>, K = 181<br>输出：<span class="hljs-comment">[4,5,5]</span><br>解释：274 + 181 = 455<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], K = <span class="hljs-number">806</span><br>输出：[<span class="hljs-number">1,0,2,1</span>]<br>解释：<span class="hljs-number">215</span> + <span class="hljs-number">806</span> = <span class="hljs-number">1021</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], K = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：<span class="hljs-number">9999999999</span> + <span class="hljs-number">1</span> = <span class="hljs-number">10000000000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 9</code></li><li><code>0 &lt;= K &lt;= 10000</code></li><li>如果 <code>A.length &gt; 1</code>，那么 <code>A[0] != 0</code></li></ol><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">addToArrayForm</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> n = A.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">int</span> temp = A[i] + (K % <span class="hljs-number">10</span>);<br>            K /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(temp &gt; <span class="hljs-number">9</span>)&#123;<br>                temp -= <span class="hljs-number">10</span>;<br>                K++;<br>            &#125;<br>            ans.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(K &gt; <span class="hljs-number">0</span>)&#123;<br>            ans.add(K % <span class="hljs-number">10</span>);<br>            K /= <span class="hljs-number">10</span>;<br>        &#125;<br>        Collections.reverse(ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1319-连通网络的操作次数"><a href="#1319-连通网络的操作次数" class="headerlink" title="1319. 连通网络的操作次数"></a><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a></h2><p>日期：<code>2021/01/23</code></p><p>用以太网线缆将 <code>n</code> 台计算机连接成一个网络，计算机的编号从 <code>0</code> 到 <code>n-1</code>。线缆用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 连接了计算机 <code>a</code> 和 <code>b</code>。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 <code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 </p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, connections = <span class="hljs-string">[[0,1],[0,2],[1,2]]</span><br>输出：<span class="hljs-number">1</span><br>解释：拔下计算机 <span class="hljs-number">1</span> 和 <span class="hljs-number">2</span> 之间的线缆，并将它插到计算机 <span class="hljs-number">1</span> 和 <span class="hljs-number">3</span> 上。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png" alt="img"></strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 6, connections = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[0,3]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>]</span><br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 6, connections = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[0,3]</span>,<span class="hljs-comment">[1,2]</span>]</span><br>输出：-1<br>解释：线缆数量不足。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 5, connections = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：0<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li><li><code>connections[i].length == 2</code></li><li><code>0 &lt;= connections[i][0], connections[i][1] &lt; n</code></li><li><code>connections[i][0] != connections[i][1]</code></li><li>没有重复的连接。</li><li>两台计算机不会通过多条线缆连接。</li></ul><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">makeConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] connections)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = n;<br>        <span class="hljs-keyword">if</span>(connections.length &lt; n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : connections)&#123;<br>            <span class="hljs-keyword">if</span>(uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]))&#123;<br>               ret--; <br>            &#125;<br>        &#125;<br>        ret--;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集的Java实现 - 算法入门</title>
    <link href="/2021/union-find-set/"/>
    <url>/2021/union-find-set/</url>
    
    <content type="html"><![CDATA[<p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集的合并及查询问题。</p><a id="more"></a><h2 id="一、并查集的基本概念和性质"><a href="#一、并查集的基本概念和性质" class="headerlink" title="一、并查集的基本概念和性质"></a>一、并查集的基本概念和性质</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>并查集是一种树型的数据结构，用于处理一些不交集的合并及查询问题。一种常用的策略是为每个集合选定一个固定的节点，称为代表，以表示整个集合。并查集主要支持两种操作：查询（<code>find</code>）和合并（<code>union</code>）</p><ul><li><code>find</code>：查询某节点的代表即查询该节点所属集合</li><li><code>union</code>：将两个不相交的子集合成为一个集合</li></ul><p>来自：<a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集 - 维基WIki</a></p><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul><li><p>等价性： 每一个节点都能连接到自己</p></li><li><p>对称性： 节点p连接到节点q等价于节点q连接到节点p</p></li><li><p>传递性： 如果节点p与节点相连且节点q与节点r相连，那么节点p与节点r相连。</p></li></ul><h2 id="二、并查集的实现（Java）"><a href="#二、并查集的实现（Java）" class="headerlink" title="二、并查集的实现（Java）"></a>二、并查集的实现（Java）</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p>初始化：将每一个节点的父节点指向自己</p></li><li><p>查找：返回当前节点所属集合的代表。若当前节点的父节点指向自己（该节点为代表）则返回当前节点，若不是则对该节点的父节点进行查找操作并返回查找的结果（递归操作）</p></li><li><p>合并：查找两个节点的代表，若代表不同（不属于同一个集合）则将其中一个节点代表的父节点指向另外一个节点的代表。</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent; <span class="hljs-comment">//存储每个节点的父节点 </span><br><br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>       <span class="hljs-comment">// 将每个节点指向自己</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">this</span>.parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找节点的代表</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> find(parent[x]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>        <span class="hljs-keyword">int</span> rootX = find(x);<br>        <span class="hljs-keyword">int</span> rootY = find(y);<br>        <span class="hljs-keyword">if</span>(rootX != rootY)&#123;<br>            parent[rootY] = rootX;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="三、-并查集的完善与优化"><a href="#三、-并查集的完善与优化" class="headerlink" title="三、 并查集的完善与优化"></a>三、 并查集的完善与优化</h2><p>之前实现的最简单的并查集可能并不平衡，比如在合并的过程中有可能会形成一条长长的链。若是在长链中寻找节点的代表需要重复向上查找父节点，这种情况的效率并不高。</p><p>那么该如何解决呢？我们可以使用<strong>按秩合并</strong>和<strong>路径压缩</strong>两种方法对其进行优化。</p><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>秩是指树的深度，秩太大会导致查询效率过低。为了尽量让秩的大小不增加，我们期望每次合并操作时都是将秩较小的树连接到秩较大的树上。若两棵树秩相同，则秩加一。</p><p>该方法需要额外的空间来保存秩.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br><br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">this</span>.parent[i] = i;<br>            <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找节点的代表</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> find(parent[x]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>        <span class="hljs-keyword">int</span> rootX = find(x);<br>        <span class="hljs-keyword">int</span> rootY = find(y);<br>        <span class="hljs-comment">//判断是否同属一个集合</span><br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>            <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>            parent[rootY] = rootX;<br>            rank[rootX]++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>            <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>            parent[rootY] = rootX;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>            parent[rootX] = rootY;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>在并查集中我们使用代表节点来判断两个节点是否属于同一个结合，但是查找代表节点需要重复地向上查找父节点。我们在查找时若时发现当前节点不是代表，那么可以将其父节点指向代表节点，这样做将极大压缩查找路径。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>其他地方无需改动，只需修改查找方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查找节点的代表</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(parent[x] != x)&#123;<br>        <span class="hljs-comment">// 将其父节点指向代表节点</span><br>        parent[x] = find(parent[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：引入路径压缩会使秩不准确。</p><h2 id="四、-并查集的应用"><a href="#四、-并查集的应用" class="headerlink" title="四、 并查集的应用"></a>四、 并查集的应用</h2><p><a href="https://keitzu.com/2021/leetcode-week-5/#1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0">1202. 交换字符串中的元素</a></p><p><a href="https://keitzu.com/2021/leetcode-week-5/#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5">684. 冗余连接</a></p><p><a href="https://keitzu.com/2021/leetcode-week-5/#947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4">947. 移除最多的同行或同列石头</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第五周</title>
    <link href="/2021/leetcode-week-5/"/>
    <url>/2021/leetcode-week-5/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a href="https://leetcode-cn.com/problems/summary-ranges/">228. 汇总区间</a></h2><p>日期：<code>2021/01/10</code></p><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-string">&quot;0-&gt;2&quot;</span>,<span class="hljs-string">&quot;4-&gt;5&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>]<br>解释：区间范围是：<br>[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] --&gt; <span class="hljs-string">&quot;0-&gt;2&quot;</span><br>[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] --&gt; <span class="hljs-string">&quot;4-&gt;5&quot;</span><br>[<span class="hljs-number">7</span>,<span class="hljs-number">7</span>] --&gt; <span class="hljs-string">&quot;7&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;2-&gt;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8-&gt;9&quot;</span>]<br>解释：区间范围是：<br>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">&quot;0&quot;</span><br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] --&gt; <span class="hljs-string">&quot;2-&gt;4&quot;</span><br>[<span class="hljs-number">6</span>,<span class="hljs-number">6</span>] --&gt; <span class="hljs-string">&quot;6&quot;</span><br>[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] --&gt; <span class="hljs-string">&quot;8-&gt;9&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">-1</span>]<br>输出：[<span class="hljs-string">&quot;-1&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-string">&quot;0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 20</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li><li><code>nums</code> 按升序排列</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>遍历一遍寻找区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">summaryRanges</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            String s = <span class="hljs-string">&quot;&quot;</span>;<br>            s += nums[start];<br>            ans.add(s);<br>        &#125;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)&#123;<br>                String s = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">if</span>(nums[start] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                    s += nums[start];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    s = nums[start] + <span class="hljs-string">&quot;-&gt;&quot;</span> + nums[i - <span class="hljs-number">1</span>];<br>                &#125;<br>                ans.add(s);<br>                start = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == nums.length - <span class="hljs-number">1</span>)&#123;<br>                String s = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">if</span>(nums[start] == nums[i])&#123;<br>                    s += nums[start];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    s = nums[start] + <span class="hljs-string">&quot;-&gt;&quot;</span> + nums[i];<br>                &#125;<br>                ans.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1202-交换字符串中的元素"><a href="#1202-交换字符串中的元素" class="headerlink" title="1202. 交换字符串中的元素"></a><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/">1202. 交换字符串中的元素</a></h2><p>日期：<code>2021/01/11</code></p><p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;dcab&quot;</span>, pairs = [[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br>输出：<span class="hljs-string">&quot;bacd&quot;</span><br>解释： <br>交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">3</span>], s = <span class="hljs-string">&quot;bcad&quot;</span><br>交换 s[<span class="hljs-number">1</span>] 和 s[<span class="hljs-number">2</span>], s = <span class="hljs-string">&quot;bacd&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;dcab&quot;</span>, pairs = [[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]<br>输出：<span class="hljs-string">&quot;abcd&quot;</span><br>解释：<br>交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">3</span>], s = <span class="hljs-string">&quot;bcad&quot;</span><br>交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">2</span>], s = <span class="hljs-string">&quot;acbd&quot;</span><br>交换 s[<span class="hljs-number">1</span>] 和 s[<span class="hljs-number">2</span>], s = <span class="hljs-string">&quot;abcd&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;cba&quot;</span>, pairs = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br>输出：<span class="hljs-string">&quot;abc&quot;</span><br>解释：<br>交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">1</span>], s = <span class="hljs-string">&quot;bca&quot;</span><br>交换 s[<span class="hljs-number">1</span>] 和 s[<span class="hljs-number">2</span>], s = <span class="hljs-string">&quot;bac&quot;</span><br>交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">1</span>], s = <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>0 &lt;= pairs.length &lt;= 10^5</code></li><li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length</code></li><li><code>s</code> 中只含有小写英文字母</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>自己的解法会超时，官方解法使用了优先队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pairs.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] ch = s.toCharArray();<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;<br>            <span class="hljs-keyword">int</span> index1 = pair.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">int</span> index2 = pair.get(<span class="hljs-number">1</span>);<br>            uf.union(index1, index2);<br>        &#125;<br>        <br>        Map&lt;Integer, List&lt;Integer&gt;&gt; union = <span class="hljs-keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">int</span> root = uf.find(i);<br>            <span class="hljs-keyword">if</span>(union.containsKey(root))&#123;<br>                union.get(root).add(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                list.add(i);<br>                union.put(root, list);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; list : union.values())&#123;<br>            sortHelper(ch, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(ch);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortHelper</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] ch, List&lt;Integer&gt; union)</span></span>&#123;<br>        Collections.sort(union);<br>        <span class="hljs-keyword">boolean</span> isFinished = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; union.size() - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; union.size() - i - <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">int</span> p = union.get(j);<br>                <span class="hljs-keyword">int</span> q = union.get(j + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(ch[p] &gt; ch[q])&#123;<br>                    <span class="hljs-keyword">char</span> temp = ch[p];<br>                    ch[p] = ch[q];<br>                    ch[q] = temp;<br>                    isFinished = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFinished)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官方解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pairs.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 1 步：将任意交换的结点对输入并查集</span><br>        <span class="hljs-keyword">int</span> len = s.length();<br>        UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(len);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;<br>            <span class="hljs-keyword">int</span> index1 = pair.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">int</span> index2 = pair.get(<span class="hljs-number">1</span>);<br>            unionFind.union(index1, index2);<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：构建映射关系</span><br>        <span class="hljs-keyword">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-comment">// key：连通分量的代表元，value：同一个连通分量的字符集合（保存在一个优先队列中）</span><br>        Map&lt;Integer, PriorityQueue&lt;Character&gt;&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">int</span> root = unionFind.find(i);<br><span class="hljs-comment">//            if (hashMap.containsKey(root)) &#123;</span><br><span class="hljs-comment">//                hashMap.get(root).offer(charArray[i]);</span><br><span class="hljs-comment">//            &#125; else &#123;</span><br><span class="hljs-comment">//                PriorityQueue&lt;Character&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="hljs-comment">//                minHeap.offer(charArray[i]);</span><br><span class="hljs-comment">//                hashMap.put(root, minHeap);</span><br><span class="hljs-comment">//            &#125;</span><br>            <span class="hljs-comment">// 上面六行代码等价于下面一行代码，JDK 1.8 以及以后支持下面的写法</span><br>            hashMap.computeIfAbsent(root, key -&gt; <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;()).offer(charArray[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 第 3 步：重组字符串</span><br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">int</span> root = unionFind.find(i);<br>            stringBuilder.append(hashMap.get(root).poll());<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 以 i 为根结点的子树的高度（引入了路径压缩以后该定义并不准确）</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (rank[rootX] == rank[rootY]) &#123;<br>                parent[rootX] = rootY;<br>                <span class="hljs-comment">// 此时以 rootY 为根结点的树的高度仅加了 1</span><br>                rank[rootY]++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;<br>                parent[rootX] = rootY;<br>                <span class="hljs-comment">// 此时以 rootY 为根结点的树的高度不变</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 同理，此时以 rootX 为根结点的树的高度不变</span><br>                parent[rootY] = rootX;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>                parent[x] = find(parent[x]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="1203-项目管理"><a href="#1203-项目管理" class="headerlink" title="1203. 项目管理"></a><a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/">1203. 项目管理</a></h2><p>日期：<code>2021/01/12</code></p><p>公司共有 <code>n</code> 个项目和  <code>m</code> 个小组，每个项目要不无人接手，要不就由 <code>m</code> 个小组之一负责。</p><p><code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果这个项目目前无人接手，那么 <code>group[i]</code> 就等于 <code>-1</code>。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><ul><li>同一小组的项目，排序后在列表中彼此相邻。</li><li>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。</li></ul><p>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表</strong> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/22/1359_ex1.png" alt="img"></strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 8, m = 2, group = <span class="hljs-comment">[-1,-1,1,0,0,1,0,-1]</span>, beforeItems = <span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[6]</span>,<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[6]</span>,<span class="hljs-comment">[3,6]</span>,<span class="hljs-comment">[]</span>,<span class="hljs-comment">[]</span>,<span class="hljs-comment">[]</span>]</span><br>输出：<span class="hljs-comment">[6,3,4,1,5,2,0,7]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 8, m = 2, group = <span class="hljs-comment">[-1,-1,1,0,0,1,0,-1]</span>, beforeItems = <span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[6]</span>,<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[6]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[]</span>,<span class="hljs-comment">[4]</span>,<span class="hljs-comment">[]</span>]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m &lt;= n &lt;= 3 * 104</code></li><li><code>group.length == beforeItems.length == n</code></li><li><code>-1 &lt;= group[i] &lt;= m - 1</code></li><li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li><li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li><li><code>i != beforeItems[i][j]</code></li><li><code>beforeItems[i]</code> 不含重复元素</li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortItems(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] group, List&lt;List&lt;Integer&gt;&gt; beforeItems) &#123;<br>        <span class="hljs-comment">// 第 1 步：数据预处理，给没有归属于一个组的项目编上组号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; group.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (group[i] == -<span class="hljs-number">1</span>) &#123;<br>                group[i] = m;<br>                m++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：实例化组和项目的邻接表</span><br>        List&lt;Integer&gt;[] groupAdj = <span class="hljs-keyword">new</span> ArrayList[m];<br>        List&lt;Integer&gt;[] itemAdj = <span class="hljs-keyword">new</span> ArrayList[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            groupAdj[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            itemAdj[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-comment">// 第 3 步：建图和统计入度数组</span><br>        <span class="hljs-keyword">int</span>[] groupsIndegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>        <span class="hljs-keyword">int</span>[] itemsIndegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">int</span> len = group.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">int</span> currentGroup = group[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> beforeItem : beforeItems.get(i)) &#123;<br>                <span class="hljs-keyword">int</span> beforeGroup = group[beforeItem];<br>                <span class="hljs-keyword">if</span> (beforeGroup != currentGroup) &#123;<br>                    groupAdj[beforeGroup].add(currentGroup);<br>                    groupsIndegree[currentGroup]++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (Integer item : beforeItems.get(i)) &#123;<br>                itemAdj[item].add(i);<br>                itemsIndegree[i]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 4 步：得到组和项目的拓扑排序结果</span><br>        List&lt;Integer&gt; groupsList = topologicalSort(groupAdj, groupsIndegree, m);<br>        <span class="hljs-keyword">if</span> (groupsList.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        List&lt;Integer&gt; itemsList = topologicalSort(itemAdj, itemsIndegree, n);<br>        <span class="hljs-keyword">if</span> (itemsList.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系</span><br>        <span class="hljs-comment">// key：组，value：在同一组的项目列表</span><br>        Map&lt;Integer, List&lt;Integer&gt;&gt; groups2Items = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Integer item : itemsList) &#123;<br>            groups2Items.computeIfAbsent(group[item], key -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()).add(item);<br>        &#125;<br><br>        <span class="hljs-comment">// 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果</span><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Integer groupId : groupsList) &#123;<br>            List&lt;Integer&gt; items = groups2Items.getOrDefault(groupId, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>            res.addAll(items);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::valueOf).toArray();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">topologicalSort</span><span class="hljs-params">(List&lt;Integer&gt;[] adj, <span class="hljs-keyword">int</span>[] inDegree, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            Integer front = queue.poll();<br>            res.add(front);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> successor : adj[front]) &#123;<br>                inDegree[successor]--;<br>                <span class="hljs-keyword">if</span> (inDegree[successor] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(successor);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (res.size() == n) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>&#125;<br><br>作者：LeetCode<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/1203-xiang-mu-guan-li-by-leetcode-t63b/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h2><p>日期：<code>2021/01/13</code></p><p>在本问题中, 树指的是一个连通且无环的<strong>无向</strong>图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以<code>边</code>组成的二维数组。每一个<code>边</code>的元素是一对<code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点<code>u</code> 和<code>v</code>的<strong>无向</strong>图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,3]</span>]</span><br>输出: <span class="hljs-comment">[2,3]</span><br>解释: 给定的无向图为:<br>  1<br> / \<br>2 - 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[3,4]</span>, <span class="hljs-comment">[1,4]</span>, <span class="hljs-comment">[1,5]</span>]</span><br>输出: <span class="hljs-comment">[1,4]</span><br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>输入的二维数组大小在 3 到 1000。</li><li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRedundantConnection(<span class="hljs-keyword">int</span>[][] edges) &#123;<br>        <span class="hljs-keyword">int</span> nodesCount = edges.length;<br>        <span class="hljs-keyword">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nodesCount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodesCount; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodesCount; i++) &#123;<br>            <span class="hljs-keyword">int</span>[] edge = edges[i];<br>            <span class="hljs-keyword">int</span> node1 = edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (find(parent, node1) != find(parent, node2)) &#123;<br>                union(parent, node1, node2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] parent, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;<br>        parent[find(parent, index1)] = find(parent, index2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] parent, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent[index] != index) &#123;<br>            parent[index] = find(parent, parent[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[index];<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/redundant-connection/solution/rong-yu-lian-jie-by-leetcode-solution-pks2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="1018-可被-5-整除的二进制前缀"><a href="#1018-可被-5-整除的二进制前缀" class="headerlink" title="1018. 可被 5 整除的二进制前缀"></a><a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/">1018. 可被 5 整除的二进制前缀</a></h2><p>日期：<code>2021/01/14</code></p><p>给定由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>。我们定义 <code>N_i</code>：从 <code>A[0]</code> 到 <code>A[i]</code> 的第 <code>i</code> 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 <code>answer</code>，只有当 <code>N_i</code> 可以被 <code>5</code> 整除时，答案 <code>answer[i]</code> 为 <code>true</code>，否则为 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>]<br>解释：<br>输入数字为 <span class="hljs-number">0</span>, <span class="hljs-number">01</span>, <span class="hljs-number">011</span>；也就是十进制中的 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span> 。只有第一个数可以被 <span class="hljs-number">5</span> 整除，因此 answer[<span class="hljs-number">0</span>] 为真。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code></li></ol><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>本来以为将二进制还原成十进制后对5取余即可，但是位数太多时会造成<code>int</code>溢出。每次运算仅保留有效部分可以解决溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">prefixesDivBy5</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = A.length;<br>        List&lt;Boolean&gt; ans= <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            num = ((num * <span class="hljs-number">2</span>) + A[i]) % <span class="hljs-number">5</span>;<br>            ans.add(num == <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h2><p>日期：<code>2021/01/15</code></p><p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[2,2]</span>]</span><br>输出：5<br>解释：一种移除 5 块石头的方法如下所示：<br>1. 移除石头 <span class="hljs-comment">[2,2]</span> ，因为它和 <span class="hljs-comment">[2,1]</span> 同行。<br>2. 移除石头 <span class="hljs-comment">[2,1]</span> ，因为它和 <span class="hljs-comment">[0,1]</span> 同列。<br>3. 移除石头 <span class="hljs-comment">[1,2]</span> ，因为它和 <span class="hljs-comment">[1,0]</span> 同行。<br>4. 移除石头 <span class="hljs-comment">[1,0]</span> ，因为它和 <span class="hljs-comment">[0,0]</span> 同列。<br>5. 移除石头 <span class="hljs-comment">[0,1]</span> ，因为它和 <span class="hljs-comment">[0,0]</span> 同行。<br>石头 <span class="hljs-comment">[0,0]</span> 不能移除，因为它没有与另一块石头同行/列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[2,0]</span>,<span class="hljs-comment">[2,2]</span>]</span><br>输出：3<br>解释：一种移除 3 块石头的方法如下所示：<br>1. 移除石头 <span class="hljs-comment">[2,2]</span> ，因为它和 <span class="hljs-comment">[2,0]</span> 同行。<br>2. 移除石头 <span class="hljs-comment">[2,0]</span> ，因为它和 <span class="hljs-comment">[0,0]</span> 同列。<br>3. 移除石头 <span class="hljs-comment">[0,2]</span> ，因为它和 <span class="hljs-comment">[0,0]</span> 同行。<br>石头 <span class="hljs-comment">[0,0]</span> 和 <span class="hljs-comment">[1,1]</span> 不能移除，因为它们没有与另一块石头同行/列。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：stones = <span class="hljs-string">[[0,0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] 是平面上唯一一块石头，所以不可以移除它。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 1000</code></li><li><code>0 &lt;= xi, yi &lt;= 104</code></li><li>不会有两块石头放在同一个坐标点上</li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>若两块石头同行或者同列，那么可以将其视为同一个集合，同一个集合的石头移除结束后只会剩余一个石头。使用并查集将所有石头划分为多个集合，然后用石头总数减去集合数量即可计算出需要移除的石头数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeStones</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] stones)</span> </span>&#123;<br>        Map&lt;Integer, Integer&gt; row = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; col = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Set&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(stones.length);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(row.containsKey(stones[i][<span class="hljs-number">0</span>]))&#123;<br>               uf.union(i, row.get(stones[i][<span class="hljs-number">0</span>])) ;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                row.put(stones[i][<span class="hljs-number">0</span>], i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(col.containsKey(stones[i][<span class="hljs-number">1</span>]))&#123;<br>               uf.union(i, col.get(stones[i][<span class="hljs-number">1</span>])) ;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                col.put(stones[i][<span class="hljs-number">1</span>], i);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.length; i++)&#123;<br>            ans.add(uf.find(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> stones.length - ans.size();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;   <span class="hljs-comment">//存储每个节点的父节点 </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;     <span class="hljs-comment">//存储节点的高度</span><br><br>        <span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-comment">// 将每个节点指向自己且秩设置为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">this</span>.parent[i] = i;<br>                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找节点的代表</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(parent[x] == x)&#123;<br>                <span class="hljs-keyword">return</span> x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> find(parent[x]);<br>        &#125;<br><br>        <span class="hljs-comment">// 合并两个节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;   <br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-comment">//判断是否同属一个集合</span><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootX] == rank[rootY])&#123;<br>                <span class="hljs-comment">// 两颗子树秩相同树高度加一</span><br>                parent[rootY] = rootX;<br>                rank[rootX]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>                <span class="hljs-comment">//将Y的树连接至秩更高的X上且秩不变</span><br>                parent[rootY] = rootX;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将X的树连接至秩更高的Y上且秩不变</span><br>                parent[rootX] = rootY;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="803-打砖块"><a href="#803-打砖块" class="headerlink" title="803. 打砖块"></a><a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/">803. 打砖块</a></h2><p>日期：<code>2021/01/16</code></p><p>有一个 <code>m x n</code> 的二元网格，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p><ul><li>一块砖直接连接到网格的顶部，或者</li><li>至少有一块相邻（4 个方向之一）砖块 <strong>稳定</strong> 不会掉落时</li></ul><p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除 <code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。</p><p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p><p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,0,0,0],[1,1,1,0]]</span>, hits = <span class="hljs-string">[[1,0]]</span><br>输出：[<span class="hljs-number">2</span>]<br>解释：<br>网格开始为：<br><span class="hljs-string">[[1,0,0,0]，</span><br><span class="hljs-string"> [1,1,1,0]]</span><br>消除 (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) 处加粗的砖块，得到网格：<br><span class="hljs-string">[[1,0,0,0]</span><br><span class="hljs-string"> [0,1,1,0]]</span><br>两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：<br><span class="hljs-string">[[1,0,0,0],</span><br><span class="hljs-string"> [0,0,0,0]]</span><br>因此，结果为 [<span class="hljs-number">2</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,0,0,0],[1,1,0,0]]</span>, hits = <span class="hljs-string">[[1,1],[1,0]]</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：<br>网格开始为：<br><span class="hljs-string">[[1,0,0,0],</span><br><span class="hljs-string"> [1,1,0,0]]</span><br>消除 (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) 处加粗的砖块，得到网格：<br><span class="hljs-string">[[1,0,0,0],</span><br><span class="hljs-string"> [1,0,0,0]]</span><br>剩下的砖都很稳定，所以不会掉落。网格保持不变：<br><span class="hljs-string">[[1,0,0,0], </span><br><span class="hljs-string"> [1,0,0,0]]</span><br>接下来消除 (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) 处加粗的砖块，得到网格：<br><span class="hljs-string">[[1,0,0,0],</span><br><span class="hljs-string"> [0,0,0,0]]</span><br>剩下的砖块仍然是稳定的，所以不会有砖块掉落。<br>因此，结果为 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li><li><code>1 &lt;= hits.length &lt;= 4 * 104</code></li><li><code>hits[i].length == 2</code></li><li><code>0 &lt;= xi &lt;= m - 1</code></li><li><code>0 &lt;= yi &lt;= n - 1</code></li><li>所有 <code>(xi, yi)</code> 互不相同</li></ul><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cols;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] DIRECTIONS = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] hitBricks(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span>[][] hits) &#123;<br>        <span class="hljs-keyword">this</span>.rows = grid.length;<br>        <span class="hljs-keyword">this</span>.cols = grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 第 1 步：把 grid 中的砖头全部击碎，通常算法问题不能修改输入数据，这一步非必需，可以认为是一种答题规范</span><br>        <span class="hljs-keyword">int</span>[][] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                copy[i][j] = grid[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 把 copy 中的砖头全部击碎</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] hit : hits) &#123;<br>            copy[hit[<span class="hljs-number">0</span>]][hit[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：建图，把砖块和砖块的连接关系输入并查集，size 表示二维网格的大小，也表示虚拟的「屋顶」在并查集中的编号</span><br>        <span class="hljs-keyword">int</span> size = rows * cols;<br>        UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(size + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 将下标为 0 的这一行的砖块与「屋顶」相连</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (copy[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                unionFind.union(j, size);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 其余网格，如果是砖块向上、向左看一下，如果也是砖块，在并查集中进行合并</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (copy[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 如果上方也是砖块</span><br>                    <span class="hljs-keyword">if</span> (copy[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                        unionFind.union(getIndex(i - <span class="hljs-number">1</span>, j), getIndex(i, j));<br>                    &#125;<br>                    <span class="hljs-comment">// 如果左边也是砖块</span><br>                    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; copy[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                        unionFind.union(getIndex(i, j - <span class="hljs-number">1</span>), getIndex(i, j));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 3 步：按照 hits 的逆序，在 copy 中补回砖块，把每一次因为补回砖块而与屋顶相连的砖块的增量记录到 res 数组中</span><br>        <span class="hljs-keyword">int</span> hitsLen = hits.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[hitsLen];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = hitsLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> x = hits[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> y = hits[i][<span class="hljs-number">1</span>];<br><br>            <span class="hljs-comment">// 注意：这里不能用 copy，语义上表示，如果原来在 grid 中，这一块是空白，这一步不会产生任何砖块掉落</span><br>            <span class="hljs-comment">// 逆向补回的时候，与屋顶相连的砖块数量也肯定不会增加</span><br>            <span class="hljs-keyword">if</span> (grid[x][y] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 补回之前与屋顶相连的砖块数</span><br>            <span class="hljs-keyword">int</span> origin = unionFind.getSize(size);<br><br>            <span class="hljs-comment">// 注意：如果补回的这个结点在第 1 行，要告诉并查集它与屋顶相连（逻辑同第 2 步）</span><br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>                unionFind.union(y, size);<br>            &#125;<br><br>            <span class="hljs-comment">// 在 4 个方向上看一下，如果相邻的 4 个方向有砖块，合并它们</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] direction : DIRECTIONS) &#123;<br>                <span class="hljs-keyword">int</span> newX = x + direction[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> newY = y + direction[<span class="hljs-number">1</span>];<br><br>                <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; copy[newX][newY] == <span class="hljs-number">1</span>) &#123;<br>                    unionFind.union(getIndex(x, y), getIndex(newX, newY));<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 补回之后与屋顶相连的砖块数</span><br>            <span class="hljs-keyword">int</span> current = unionFind.getSize(size);<br>            <span class="hljs-comment">// 减去的 1 是逆向补回的砖块（正向移除的砖块），与 0 比较大小，是因为存在一种情况，添加当前砖块，不会使得与屋顶连接的砖块数更多</span><br>            res[i] = Math.max(<span class="hljs-number">0</span>, current - origin - <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 真正补上这个砖块</span><br>            copy[x][y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 输入坐标在二维网格中是否越界</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 二维坐标转换为一维坐标</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * cols + y;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当前结点的父亲结点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 以当前结点为根结点的子树的结点总数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                parent[i] = i;<br>                size[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 路径压缩，只要求每个不相交集合的「根结点」的子树包含的结点总数数值正确即可，因此在路径压缩的过程中不用维护数组 size</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>                parent[x] = find(parent[x]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br><br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            parent[rootX] = rootY;<br>            <span class="hljs-comment">// 在合并的时候维护数组 size</span><br>            size[rootY] += size[rootX];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> x 在并查集的根结点的子树包含的结点总数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> root = find(x);<br>            <span class="hljs-keyword">return</span> size[root];<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/bricks-falling-when-hit/solution/803-da-zhuan-kuai-by-leetcode-r5kf/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列简单介绍</title>
    <link href="/2021/message-queue/"/>
    <url>/2021/message-queue/</url>
    
    <content type="html"><![CDATA[<p>在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。</p><a id="more"></a><h2 id="消息队列是什么"><a href="#消息队列是什么" class="headerlink" title="消息队列是什么"></a>消息队列是什么</h2><p>消息队列其实就是一个存放消息的容器，生产者可以产生消息放入这个容器，而消费者可以从这个容器中获取消息。</p><p>消息队列是分布式系统中重要的组件之一。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。</p><h2 id="消息队列的好处"><a href="#消息队列的好处" class="headerlink" title="消息队列的好处"></a>消息队列的好处</h2><p>消息队列有三大好处</p><ol><li><p>异步处理提升性能</p></li><li><p>高并发下流量削峰</p></li><li><p>模块之间降低耦合</p></li></ol><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>生产者将生产的消息发送存储到消息队列之后便可以立即进行其他操作，无需等待消费者消费。消费者可以在之后从消息队列中获取消息进行处理</p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>高并发的场景下可以将压力转移到消息队列上，消费者可以按照其处理能力平稳的从消息队列中获取消息进行处理。</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>使用消息队列之后，生产者和消费者之间并不直接调用，降低了模块间的耦合。</p><h2 id="消息队列带来的问题"><a href="#消息队列带来的问题" class="headerlink" title="消息队列带来的问题"></a>消息队列带来的问题</h2><h3 id="系统复杂性增加"><a href="#系统复杂性增加" class="headerlink" title="系统复杂性增加"></a>系统复杂性增加</h3><p>增加消息队列之后，需要考虑消息的消费情况以及消息队列服务器的情况</p><h3 id="消息一致性问题"><a href="#消息一致性问题" class="headerlink" title="消息一致性问题"></a>消息一致性问题</h3><p>增加消息队列之后，需要考虑生产者与消费者之间消息是否一致</p><blockquote><p>参考：</p><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/message-queue?id=%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%85%b6%e5%ae%9e%e5%be%88%e7%ae%80%e5%8d%95">消息队列其实很简单 - JavaGuide</a></li><li><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列 - CS Notes</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第四周</title>
    <link href="/2021/leetcode-week-4/"/>
    <url>/2021/leetcode-week-4/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h2><p>日期：<code>2021/01/03</code></p><p>给你一个链表和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有小于 <code>x</code> 的节点都出现在大于或等于 <code>x</code> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：head = <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>, x = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用两个带头节点的链表临时存储大于等于x与小于x的节点，遍历链表将符合条件的节点移动到对应链表。最后将两个链表合二为一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        ListNode smallHead = <span class="hljs-keyword">new</span> ListNode();<br>        ListNode smallRear = smallHead;<br>        ListNode bigHead = <span class="hljs-keyword">new</span> ListNode();<br>        ListNode bigRear = bigHead;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val &gt;= x)&#123;<br>                bigRear.next = head;<br>                bigRear = bigRear.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                smallRear.next = head;<br>                smallRear = smallRear.next;<br>            &#125;<br>            <br>            head = head.next;<br>        &#125;<br>        bigRear.next = <span class="hljs-keyword">null</span>;<br>        smallRear.next = bigHead.next;<br>        <span class="hljs-keyword">return</span> smallHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h2><p>日期：<code>2021/01/04</code></p><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(0)</span> = <span class="hljs-number">0</span>，<span class="hljs-constructor">F(1)</span> = <span class="hljs-number">1</span><br><span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span> = <span class="hljs-constructor">F(<span class="hljs-params">n</span> - 1)</span> + <span class="hljs-constructor">F(<span class="hljs-params">n</span> - 2)</span>，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：F<span class="hljs-comment">(2)</span> = F<span class="hljs-comment">(1)</span> + F<span class="hljs-comment">(0)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：F<span class="hljs-comment">(3)</span> = F<span class="hljs-comment">(2)</span> + F<span class="hljs-comment">(1)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">4</span><br>输出：<span class="hljs-number">3</span><br>解释：F<span class="hljs-comment">(4)</span> = F<span class="hljs-comment">(3)</span> + F<span class="hljs-comment">(2)</span> = <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">2</span>) + fib(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>        nums[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        nums[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>            nums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">1</span>];<br>            nums[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">2</span>];<br>            nums[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">830. 较大分组的位置</a></h2><p>日期：<code>2021/01/05</code></p><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;abbxxxxzzy&quot;</span><br>输出：<span class="hljs-string">[[3,6]]</span><br>解释：<span class="hljs-string">&quot;xxxx&quot;</span> 是一个起始于 <span class="hljs-number">3</span> 且终止于 <span class="hljs-number">6</span> 的较大分组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[]<br>解释：<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span> 和 <span class="hljs-string">&quot;c&quot;</span> 均不是符合要求的较大分组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;abcdddeeeeaabbbcd&quot;</span><br>输出：<span class="hljs-string">[[3,5],[6,9],[12,14]]</span><br>解释：较大分组为 <span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-string">&quot;eeee&quot;</span> 和 <span class="hljs-string">&quot;bbb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aba&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅含小写英文字母</li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>依次遍历数组，记录字符出现次数，若大于3则在答案中加入位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;<br>        <span class="hljs-keyword">char</span>[] charArray = s.toCharArray();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; pos = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(charArray[i] == charArray[i - <span class="hljs-number">1</span>])&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">2</span>)&#123;<br>                    pos.add(start);<br>                    pos.add(i - <span class="hljs-number">1</span>);<br>                    ans.add(pos);<br>                    pos = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                &#125;<br>                start = i;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">2</span>)&#123;<br>            pos.add(start);<br>            pos.add(s.length() - <span class="hljs-number">1</span>);<br>            ans.add(pos);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h2><p>日期：<code>2021/01/06</code></p><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]], values = [<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>]]<br>输出：[<span class="hljs-number">6.00000</span>,<span class="hljs-number">0.50000</span>,<span class="hljs-number">-1.00000</span>,<span class="hljs-number">1.00000</span>,<span class="hljs-number">-1.00000</span>]<br>解释：<br>条件：a / b = <span class="hljs-number">2.0</span>, b / c = <span class="hljs-number">3.0</span><br>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>结果：[<span class="hljs-number">6.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span> ]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]], values = [<span class="hljs-number">1.5</span>,<span class="hljs-number">2.5</span>,<span class="hljs-number">5.0</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>],[<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>]]<br>输出：[<span class="hljs-number">3.75000</span>,<span class="hljs-number">0.40000</span>,<span class="hljs-number">5.00000</span>,<span class="hljs-number">0.20000</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]], values = [<span class="hljs-number">0.5</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>]]<br>输出：[<span class="hljs-number">0.50000</span>,<span class="hljs-number">2.00000</span>,<span class="hljs-number">-1.00000</span>,<span class="hljs-number">-1.00000</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= equations.length &lt;= 20</code></p></li><li><p><code>equations[i].length == 2</code></p></li><li><p><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></p></li><li><p><code>values.length == equations.length</code></p></li><li><p><code>0.0 &lt; values[i] &lt;= 20.0</code></p></li><li><p><code>1 &lt;= queries.length &lt;= 20</code></p></li><li><p><code>queries[i].length == 2</code></p></li><li><p><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></p></li><li><p><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</p></li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-keyword">int</span> nvars = <span class="hljs-number">0</span>;<br>        Map&lt;String, Integer&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();<br><br>        <span class="hljs-keyword">int</span> n = equations.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!variables.containsKey(equations.get(i).get(<span class="hljs-number">0</span>))) &#123;<br>                variables.put(equations.get(i).get(<span class="hljs-number">0</span>), nvars++);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!variables.containsKey(equations.get(i).get(<span class="hljs-number">1</span>))) &#123;<br>                variables.put(equations.get(i).get(<span class="hljs-number">1</span>), nvars++);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于每个点，存储其直接连接到的所有点及对应的权值</span><br>        List&lt;Pair&gt;[] edges = <span class="hljs-keyword">new</span> List[nvars];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nvars; i++) &#123;<br>            edges[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Pair&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> va = variables.get(equations.get(i).get(<span class="hljs-number">0</span>)), vb = variables.get(equations.get(i).get(<span class="hljs-number">1</span>));<br>            edges[va].add(<span class="hljs-keyword">new</span> Pair(vb, values[i]));<br>            edges[vb].add(<span class="hljs-keyword">new</span> Pair(va, <span class="hljs-number">1.0</span> / values[i]));<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> queriesCount = queries.size();<br>        <span class="hljs-keyword">double</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queriesCount];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queriesCount; i++) &#123;<br>            List&lt;String&gt; query = queries.get(i);<br>            <span class="hljs-keyword">double</span> result = -<span class="hljs-number">1.0</span>;<br>            <span class="hljs-keyword">if</span> (variables.containsKey(query.get(<span class="hljs-number">0</span>)) &amp;&amp; variables.containsKey(query.get(<span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-keyword">int</span> ia = variables.get(query.get(<span class="hljs-number">0</span>)), ib = variables.get(query.get(<span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span> (ia == ib) &#123;<br>                    result = <span class="hljs-number">1.0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Queue&lt;Integer&gt; points = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>                    points.offer(ia);<br>                    <span class="hljs-keyword">double</span>[] ratios = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[nvars];<br>                    Arrays.fill(ratios, -<span class="hljs-number">1.0</span>);<br>                    ratios[ia] = <span class="hljs-number">1.0</span>;<br><br>                    <span class="hljs-keyword">while</span> (!points.isEmpty() &amp;&amp; ratios[ib] &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">int</span> x = points.poll();<br>                        <span class="hljs-keyword">for</span> (Pair pair : edges[x]) &#123;<br>                            <span class="hljs-keyword">int</span> y = pair.index;<br>                            <span class="hljs-keyword">double</span> val = pair.value;<br>                            <span class="hljs-keyword">if</span> (ratios[y] &lt; <span class="hljs-number">0</span>) &#123;<br>                                ratios[y] = ratios[x] * val;<br>                                points.offer(y);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    result = ratios[ib];<br>                &#125;<br>            &#125;<br>            ret[i] = result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index;<br>    <span class="hljs-keyword">double</span> value;<br><br>    Pair(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">double</span> value) &#123;<br>        <span class="hljs-keyword">this</span>.index = index;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/evaluate-division/solution/chu-fa-qiu-zhi-by-leetcode-solution-8nxb/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h2><p>日期：<code>2021/01/07</code></p><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：isConnected = <span class="hljs-string">[[1,1,0],[1,1,0],[0,0,1]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：isConnected = <span class="hljs-string">[[1,0,0],[0,1,0],[0,0,1]]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n == isConnected.length</code></li><li><code>n == isConnected[i].length</code></li><li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li><li><code>isConnected[i][i] == 1</code></li><li><code>isConnected[i][j] == isConnected[j][i]</code></li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>遍历每个城市，若城市<code>i</code>未被访问（<code>isConnected[i][i] == 1</code>），寻找与其相连的城市（<code>isConnected[i][j]</code>或者<code>isConnected[j][i]</code>等于1），将其置为<code>0</code>之后对城市<code>j</code>执行相同操作并将<code>isConnected[i][i]</code>置为<code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span>[][] isConnected;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isConnected = isConnected;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 依次遍历城市，若未访问则寻找其相连城市</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; isConnected.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(isConnected[i][i] == <span class="hljs-number">1</span>)&#123;<br>                buildHelper(i);<br>                ans++; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-comment">// 寻找同一行中的相连城市</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; isConnected.length; j++)&#123;<br>            <span class="hljs-comment">// 若相连则去除相连标记并寻找下一城市的相连城市</span><br>            <span class="hljs-keyword">if</span>(isConnected[i][j] == <span class="hljs-number">1</span>)&#123;<br>                isConnected[i][j] = <span class="hljs-number">0</span>;<br>                buildHelper(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 寻找同一列中的相连城市</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-comment">// 若相连则去除相连标记并寻找下一城市的相连城市</span><br>            <span class="hljs-keyword">if</span>(isConnected[j][i] == <span class="hljs-number">1</span>)&#123;<br>                isConnected[j][i] = <span class="hljs-number">0</span>;<br>                buildHelper(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 该城市标记为已访问</span><br>        isConnected[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h2><p>日期：<code>2021/01/08</code></p><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[1,2,3,4,5,6,7]</span> 和 k = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">[5,6,7,1,2,3,4]</span><br>解释:<br>向右旋转 <span class="hljs-number">1</span> 步: <span class="hljs-string">[7,1,2,3,4,5,6]</span><br>向右旋转 <span class="hljs-number">2</span> 步: <span class="hljs-string">[6,7,1,2,3,4,5]</span><br>向右旋转 <span class="hljs-number">3</span> 步: <span class="hljs-string">[5,6,7,1,2,3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: [<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3,99] 和 k = 2<br>输出: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br>解释: <br>向右旋转 1 步: [99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3]<br>向右旋转 2 步: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>解法一：保存最后一个元素后将其他元素后移一位，将最后一个元素置于第一位，重复<code>k</code>次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            temp = nums[n];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>                nums[j] = nums[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            nums[<span class="hljs-number">0</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法二：先将数组翻转，然后前<code>k</code>位再翻转一次，剩余部分翻转一次。注意翻转前需要处理<code>k</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left; i &lt; (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">int</span> temp = nums[i];<br>            nums[i] = nums[right - i + left];<br>            nums[right - i + left] = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        k %= n;<br>        reserve(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        reserve(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        reserve(nums, k , n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法三：直接计算出每个位置的最后位置然后进行移动。将所有数字按<code>n % k</code>的值分为<code>k</code>组，遍历每组元素依次替代下一位元素位置，保存每组最后一位元素，最后将其置于数组开始前<code>k</code>位。这个解法空间复杂度不符合要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> lastInt;<br>    <span class="hljs-keyword">int</span>[] nums;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">int</span>[] lastNums;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.nums = nums;<br>        k %= nums.length;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        lastNums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            lastInt = nums[i];<br>            helper(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            nums[i] = lastNums[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n + k &gt;= nums.length)&#123;<br>            lastNums[(n + k) % nums.length] = lastInt;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> temp = lastInt;<br>            lastInt = nums[n + k];<br>            nums[n + k] = temp;<br>            helper(n + k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2><p>日期：<code>2021/01/09</code></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第<span class="hljs-number"> 4 </span>天（股票价格 = 0）的时候买入，在第<span class="hljs-number"> 6 </span>天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。<br>     随后，在第<span class="hljs-number"> 7 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 8 </span>天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。   <br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。   <br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span> <br>输出：<span class="hljs-number">0</span> <br>解释：在这个情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：prices </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-keyword">int</span> buy1 = -prices[<span class="hljs-number">0</span>], sell1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> buy2 = -prices[<span class="hljs-number">0</span>], sell2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            buy1 = Math.max(buy1, -prices[i]);<br>            sell1 = Math.max(sell1, buy1 + prices[i]);<br>            buy2 = Math.max(buy2, sell1 - prices[i]);<br>            sell2 = Math.max(sell2, buy2 + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell2;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第三周</title>
    <link href="/2020/leetcode-week-3/"/>
    <url>/2020/leetcode-week-3/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a></h2><p>日期：<code>2020/12/27</code></p><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;add&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;bar&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;paper&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;title&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设 <strong><em>s</em></strong> 和 <strong><em>t\</em></strong> 具有相同的长度。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>与之前的题目类似，将字符串中的字符依次放入<code>Map</code>中，若键值对已存在但值不同或者键并存在值存在的情况返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] charS = s.toCharArray();<br>        <span class="hljs-keyword">char</span>[] charT = t.toCharArray();<br>        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>           <span class="hljs-keyword">if</span>(map.containsKey(charS[i]) &amp;&amp; !map.get(charS[i]).equals(charT[i])) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!map.containsKey(charS[i]) &amp;&amp; map.containsValue(charT[i]))&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               map.put(charS[i],charT[i]);<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2><p>日期：<code>2020/12/28</code></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">k</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">prices</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：在第 <span class="hljs-number">1</span> 天 (股票价格 = <span class="hljs-number">2</span>) 的时候买入，在第 <span class="hljs-number">2</span> 天 (股票价格 = <span class="hljs-number">4</span>) 的时候卖出，这笔交易所能获得利润 = <span class="hljs-number">4</span><span class="hljs-attr">-2</span> = <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天 (股票价格 = 2) 的时候买入，在第<span class="hljs-number"> 3 </span>天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 5 </span>天 (股票价格 = 0) 的时候买入，在第<span class="hljs-number"> 6 </span>天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 109</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>动态规划官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prices.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        k = Math.min(k, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">int</span>[][] buy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span>[][] sell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];<br><br>        buy[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        sell[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>            buy[<span class="hljs-number">0</span>][i] = sell[<span class="hljs-number">0</span>][i] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            buy[i][<span class="hljs-number">0</span>] = Math.max(buy[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], sell[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>                buy[i][j] = Math.max(buy[i - <span class="hljs-number">1</span>][j], sell[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>                sell[i][j] = Math.max(sell[i - <span class="hljs-number">1</span>][j], buy[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + prices[i]);   <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Arrays.stream(sell[n - <span class="hljs-number">1</span>]).max().getAsInt();<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="330-按要求补齐数组"><a href="#330-按要求补齐数组" class="headerlink" title="330. 按要求补齐数组"></a><a href="https://leetcode-cn.com/problems/patching-array/">330. 按要求补齐数组</a></h2><p>日期：<code>2020/12/29</code></p><p>给定一个已排序的正整数数组 <em>nums，</em>和一个正整数 <em>n 。</em>从 <code>[1, n]</code> 区间内选取任意个数字补充到 <em>nums</em> 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 <em>nums</em> 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,3]</span>, n = 6<br>输出: 1 <br>解释:<br>根据 nums 里现有的组合 <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[1,3]</span>，可以得出 1, 3, 4。<br>现在如果我们将 2 添加到 nums 中， 组合变为: <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[1,2,3]</span>。<br>其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 <span class="hljs-comment">[1, 6]</span> 区间里所有的数。<br>所以我们最少需要添加一个数字。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,5,10], n = 20</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: 我们需要添加 [2, 4]。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,2,2], n = 5</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPatches</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> patches = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> x = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> length = nums.length, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            <span class="hljs-keyword">if</span> (index &lt; length &amp;&amp; nums[index] &lt;= x) &#123;<br>                x += nums[index];<br>                index++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                x *= <span class="hljs-number">2</span>;<br>                patches++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> patches;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></h2><p>日期：<code>2020/12/30</code></p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2,7,4,1,8,1]</span><br>输出：1<br>解释：<br>先选出 7 和 8，得到 1，所以数组转换为 <span class="hljs-selector-attr">[2,4,1,1,1]</span>，<br>再选出 2 和 4，得到 2，所以数组转换为 <span class="hljs-selector-attr">[2,1,1,1]</span>，<br>接着是 2 和 1，得到 1，所以数组转换为 <span class="hljs-selector-attr">[1,1,1]</span>，<br>最后选出 1 和 1，得到 0，最终数组转换为 <span class="hljs-selector-attr">[1]</span>，这就是最后剩下那块石头的重量。<br></code></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>每次将数组排序选出最重两块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] stones)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stone : stones) &#123;<br>            list.add(stone);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(list.size() &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">int</span> n = list.size();<br>            Collections.sort(list);<br>            <span class="hljs-keyword">if</span>(list.get(n - <span class="hljs-number">1</span>) == list.get(n - <span class="hljs-number">2</span>))&#123;<br>                list.remove(n - <span class="hljs-number">1</span>);<br>                list.remove(n - <span class="hljs-number">2</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> left = list.get(n - <span class="hljs-number">1</span>) - list.get(n - <span class="hljs-number">2</span>);<br>                list.set(n - <span class="hljs-number">2</span>, left);<br>                list.remove(n - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.isEmpty()? <span class="hljs-number">0</span> :list.get(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p>日期：<code>2020/12/31</code></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[3,4]</span>, <span class="hljs-comment">[1,3]</span> ]</span><br><br>输出: 1<br><br>解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span> ]</span><br><br>输出: 2<br><br>解释: 你需要移除两个 <span class="hljs-comment">[1,2]</span> 来使剩下的区间没有重叠。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span> ]</span><br><br>输出: 0<br><br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br></code></pre></td></tr></table></figure><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>动态规划官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">0</span>] - interval2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> n = intervals.length;<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(f, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (intervals[j][<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                    f[i] = Math.max(f[i], f[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - Arrays.stream(f).max().getAsInt();<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h2><p>日期：<code>2021/01/01</code></p><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">flowerbed</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">flowerbed</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>需要额外标志位记录上一个花坛状态，遍历数组，若当前位置的前一位和后一位均为0则可以种植，标志位置为1。第一个和最后一个位置需要特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] flowerbed, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> last = flowerbed[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(flowerbed.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>                max++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> max &lt; n ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>            last = <span class="hljs-number">1</span>;<br>            max++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; flowerbed.length - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(last == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                last = <span class="hljs-number">1</span>;<br>                max++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                last = flowerbed[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(last == <span class="hljs-number">0</span> &amp;&amp; flowerbed[flowerbed.length - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>            max++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max &lt; n ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>日期：<code>2021/01/02</code></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,-1]</span>, k = 1<br>输出：<span class="hljs-comment">[1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[9,11]</span>, k = 2<br>输出：<span class="hljs-comment">[11]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,-2]</span>, k = 2<br>输出：<span class="hljs-comment">[4]</span><br></code></pre></td></tr></table></figure><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>可以使用一个数组或者队列保存需要比较的数字，但是时间复杂度太高会超时。</p><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt;(<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pair1, <span class="hljs-keyword">int</span>[] pair2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> pair1[<span class="hljs-number">0</span>] != pair2[<span class="hljs-number">0</span>] ? pair2[<span class="hljs-number">0</span>] - pair1[<span class="hljs-number">0</span>] : pair2[<span class="hljs-number">1</span>] - pair1[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nums[i], i&#125;);<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n - k + <span class="hljs-number">1</span>];<br>        ans[<span class="hljs-number">0</span>] = pq.peek()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; n; ++i) &#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nums[i], i&#125;);<br>            <span class="hljs-keyword">while</span> (pq.peek()[<span class="hljs-number">1</span>] &lt;= i - k) &#123;<br>                pq.poll();<br>            &#125;<br>            ans[i - k + <span class="hljs-number">1</span>] = pq.peek()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第二周</title>
    <link href="/2020/leetcode-week-2/"/>
    <url>/2020/leetcode-week-2/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></h2><p>日期：<code>2020/12/20</code></p><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。 </p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;bcabc&quot;</span><br>输出：<span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbacdcbc&quot;</span><br>输出：<span class="hljs-string">&quot;acdb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>官方解答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            num[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (!vis[ch - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>                <span class="hljs-keyword">while</span> (sb.length() &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="hljs-number">1</span>) &gt; ch) &#123;<br>                    <span class="hljs-keyword">if</span> (num[sb.charAt(sb.length() - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                        vis[sb.charAt(sb.length() - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">false</span>;<br>                        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                vis[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;<br>                sb.append(ch);<br>            &#125;<br>            num[ch - <span class="hljs-string">&#x27;a&#x27;</span>] -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><p>日期：<code>2020/12/21</code></p><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 <code>0</code> 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span><br>输出：15<br>解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。<br></code></pre></td></tr></table></figure><p> <strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>输出：6<br>解释：最低花费方式是从 cost<span class="hljs-comment">[0]</span> 开始，逐个经过那些 1 ，跳过 cost<span class="hljs-comment">[3]</span> ，一共花费 6 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>cost</code> 的长度范围是 <code>[2, 1000]</code>。</li><li><code>cost[i]</code> 将会是一个整型数据，范围为 <code>[0, 999]</code> 。</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>动态规划问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = cost.length;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>日期：<code>2020/12/22</code></p><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>使用队列对树进行层次遍历，增加一个标志位判断是否需要将该层节点倒置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans =  <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">boolean</span> left = <span class="hljs-keyword">true</span>;<br>         Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>         queue.add(root);<br>         <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> count = queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;<br>                TreeNode node = queue.poll();<br>                level.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!left)&#123;<br>                Collections.reverse(level);<br>            &#125;<br>            ans.add(level);<br>            left = !left;<br>         &#125;<br>         <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">387. 字符串中的第一个唯一字符</a></h2><p>日期：<code>2020/12/23</code></p><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span><br>返回 <span class="hljs-number">0</span><br><br><span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;loveleetcode&quot;</span><br>返回 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>遍历两次，第一次计算字符出现次数，第二次遍历返回第一个次数为1的字符索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; frequency = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            frequency.put(ch, frequency.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (frequency.get(s.charAt(i)) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h2><p>日期：<code>2020/12/24</code></p><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,0,2]</span><br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,2]</span><br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。<br></code></pre></td></tr></table></figure><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>官方题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ratings)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = ratings.length;<br>        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                right++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = <span class="hljs-number">1</span>;<br>            &#125;<br>            ret += Math.max(left[i], right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h2><p>日期：<code>2020/12/25</code></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;<br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-keyword">int</span> numOfChildren = g.length, numOfCookies = s.length;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; numOfChildren &amp;&amp; j &lt; numOfCookies; i++, j++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; numOfCookies &amp;&amp; g[i] &gt; s[j]) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &lt; numOfCookies) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></h2><p>日期：<code>2020/12/26</code></p><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：matrix </span>=<span class="hljs-string"> []</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;1&quot;]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;,&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>官方题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> width = left[i][j];<br>                <span class="hljs-keyword">int</span> area = width;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    width = Math.min(width, left[k][j]);<br>                    area = Math.max(area, (i - k + <span class="hljs-number">1</span>) * width);<br>                &#125;<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo + 腾讯云快速上传截图 - Hexo博客图床搭建</title>
    <link href="/2020/picgo/"/>
    <url>/2020/picgo/</url>
    
    <content type="html"><![CDATA[<p><strong>PicGo是一个用于快速上传图片并获取图片 URL 链接的工具，我们可以配置PicGo与对象存储服务来实现截图的快速上传，这里我选用腾讯云对象存储作为示范。</strong></p><a id="more"></a><p>工具列表：</p><ul><li><a href="https://molunerfinn.com/PicGo/">Picgo</a></li><li><a href="https://console.cloud.tencent.com/cos5">腾讯云对象存储</a></li></ul><h2 id="1、PicGo下载"><a href="#1、PicGo下载" class="headerlink" title="1、PicGo下载"></a>1、PicGo下载</h2><p><img src="https://static.kezi.xyz/images/post/2020/picgo-1.png" alt="PicGO主页"></p><p>下载地址：<a href="https://github.com/Molunerfinn/picgo/releases">Picgo</a></p><p> 特色功能</p><ul><li><p>支持拖拽图片上传</p></li><li><p>支持快捷键上传剪贴板里第一张图片</p></li><li><p>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</p></li><li><p>上传图片后自动复制链接到剪贴板</p></li><li><p>支持自定义复制到剪贴板的链接格式</p></li><li><p>支持修改快捷键，默认快速上传快捷键：<code>command+shift+p</code>（macOS）| <code>control+shift+p</code>（Windows\Linux)</p></li><li><p>支持插件系统，已有插件支持 Gitee、青云等第三方图床</p><ul><li>更多第三方插件以及使用了 PicGo 底层的应用可以在 <a href="https://github.com/PicGo/Awesome-PicGo">Awesome-PicGo</a> 找到。欢迎贡献！    </li></ul></li></ul><p>注意</p><p>请确保你安装了 Node.js， 并且版本 &gt;= 8。</p><h2 id="2、腾讯云相关配置"><a href="#2、腾讯云相关配置" class="headerlink" title="2、腾讯云相关配置"></a>2、腾讯云相关配置</h2><p>打开并登陆<a href="https://console.cloud.tencent.com/cos5/bucket">腾讯COS存储桶列表</a>创建存储桶，访问权限设置为共有读私有写。对象存储新用户有6个月的免费额度。</p><p><img src="https://static.kezi.xyz/images/post/2020/picgo-2.png" alt="创建存储桶"></p><p>打开<a href="https://console.cloud.tencent.com/cam/capi">API密钥管理</a>新建密钥，找到自己的<code>APPID</code>、<code>SecretId</code>、<code>SecretKey</code>。</p><p><img src="https://static.kezi.xyz/images/post/2020/picgo-3.png" alt="密钥管理"></p><h2 id="3、PicGo相关配置"><a href="#3、PicGo相关配置" class="headerlink" title="3、PicGo相关配置"></a>3、PicGo相关配置</h2><p>打开PicGo - 图床设置 - 腾讯云COS，按照提示填写配置信息。</p><p>存储的空间名是你的bucket名字。</p><p>存储的区域需要额外注意，请到bucket列表里打开需要上传的bucket空间，然后如图可以看到对应的区域以及区域代码。</p><p>如果你想把图片上传到你的bucket空间的某个文件夹下，则需要在PicGo里的<code>指定存储路径</code>里加上你的文件夹路径。比如<code>temp/</code>（注意一定要加<code>/</code>）</p><p><img src="https://static.kezi.xyz/images/post/2020/picgo-4.png" alt="腾讯云COS配置"></p><p>记得点击确定以及设置为默认图床。</p><p>然后打开PicGO设置界面设置快捷键</p><p><img src="https://static.kezi.xyz/images/post/2020/picgo-5.png" alt="设置快捷键"></p><p>最小化程序，使用QQ之类的截图然后就可以快捷键上传图片了。图片上传完成之后会自动复制带链接的Markdown图片格式，你也可以自定义格式。</p><p>另外，建议将上传前重命名打开，截图自带的是时间命名，不好管理。</p><p><img src="https://static.kezi.xyz/images/post/2020/picgo-6.png" alt="上传前重命名"></p>]]></content>
    
    
    <categories>
      
      <category>实用总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Picgo</tag>
      
      <tag>腾讯云</tag>
      
      <tag>对象存储</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode每日一题 - 第一周</title>
    <link href="/2020/leetcode-week-1/"/>
    <url>/2020/leetcode-week-1/</url>
    
    <content type="html"><![CDATA[<p>力扣（<em>LeetCode</em>）是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌，为全球程序员提供了专业的IT 技术职业化提升平台。每日练习LeetCode中的题目可以锻炼解决问题的思维能力，加深计算机数据结构与算法的理解。</p><a id="more"></a><h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h2><p>日期：<code>2020/12/13</code></p><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,1]</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,4]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">1,1,1,3</span>,<span class="hljs-number">3,4,3,2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出: true<br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将数组依次插入不允许重复值存在的Set中，若插入失败则含有重复元素，直接返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        HashSet map = <span class="hljs-keyword">new</span> HashSet();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = i; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(nums[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h2><p>日期：<code>2020/12/14</code></p><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出:<br>[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>字母异位词拥有相同的字母，将字母异位词的字母排序之后拥有相同的一个字符串。遍历该数组，将字符串的字母排序后作为Key，向Value中添加该字符串。最后将所有Value转换为List输出即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();<br>        Map&lt;String, List&gt; ans = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++)&#123;<br>            String str = strs[i];<br>            <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>            Arrays.sort(chars);<br>            String key = String.valueOf(chars);<br>            <span class="hljs-keyword">if</span>(!ans.containsKey(key))&#123;<br>               ans.put(key, <span class="hljs-keyword">new</span> ArrayList()); <br>            &#125; <br>            ans.get(key).add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(ans.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h2><p>日期：<code>2020/12/15</code></p><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 10</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 1234</span><br><span class="hljs-section">输出: 1234</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 332</span><br><span class="hljs-section">输出: 299</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong> <code>N</code> 是在 <code>[0, 10^9]</code> 范围内的一个整数。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>从高位至低位先找出单调递增的最低位数<code>i</code>，第<code>i</code>位数字减一，然后剩余位置为<code>9</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] strN = Integer.toString(N).toCharArray();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; strN.length &amp;&amp; strN[i - <span class="hljs-number">1</span>] &lt;= strN[i]) &#123;<br>            i += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; strN.length) &#123;<br>            <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; strN[i - <span class="hljs-number">1</span>] &gt; strN[i]) &#123;<br>                strN[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>                i -= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (i += <span class="hljs-number">1</span>; i &lt; strN.length; ++i) &#123;<br>                strN[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(<span class="hljs-keyword">new</span> String(strN));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h2><p>日期：<code>2020/12/16</code></p><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">&quot;abba&quot;</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">&quot;dog cat cat dog&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入:<span class="hljs-attr">pattern</span> = <span class="hljs-string">&quot;abba&quot;</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">&quot;dog cat cat fish&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">&quot;dog cat cat dog&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">&quot;abba&quot;</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">&quot;dog dog dog dog&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设 <code>pattern</code> 只包含小写字母， <code>str</code> 包含了由单个空格分隔的小写字母。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>将<code>pattern</code>中的字符作为<code>Map</code>的<code>Key</code>，<code>str</code>中的单词作为<code>Value</code>。将字符和单词依次放入<code>Map</code>中，若存入时键值对已存在但当前值不同或者不同<code>Key</code>的值相同，则输出<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(String pattern, String s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] patternList = pattern.toCharArray();<br>        String[] strList = s.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span>(patternList.length != strList.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        Map&lt;Character, String&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strList.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(patternList[i]) &amp;&amp; !map.get(patternList[i]).equals(strList[i]))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!map.containsKey(patternList[i]) &amp;&amp; map.containsValue(strList[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                map.put(patternList[i], strList[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h2><p>日期：<code>2020/12/17</code></p><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: prices = <span class="hljs-comment">[1, 3, 2, 8, 4, 9]</span>, fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:  <br>在此处买入 prices<span class="hljs-comment">[0]</span> = 1<br>在此处卖出 prices<span class="hljs-comment">[3]</span> = 8<br>在此处买入 prices<span class="hljs-comment">[4]</span> = 4<br>在此处卖出 prices<span class="hljs-comment">[5]</span> = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>0 &lt; prices.length &lt;= 50000</code>.</li><li><code>0 &lt; prices[i] &lt; 50000</code>.</li><li><code>0 &lt;= fee &lt; 50000</code>.</li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>动态规划问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i] - fee);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a><a href="https://leetcode-cn.com/problems/find-the-difference/">389. 找不同</a></h2><p>日期：<code>2020/12/18</code></p><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p><p>字符串 <strong><em>t</em></strong> 由字符串 <strong><em>s</em></strong> 随你机重排，然后在随机位置添加一个字母。</p><p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;abcde&quot;</span><br>输出：<span class="hljs-string">&quot;e&quot;</span><br>解释：&#x27;e&#x27; 是那个被添加的字母。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;y&quot;</span><br>输出：<span class="hljs-string">&quot;y&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;aa&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;aea&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>将两个字符串顺序之后按字符依次比较，若出现不同字符即返回<code>t</code>中的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] charS = s.toCharArray();<br>        <span class="hljs-keyword">char</span>[] charT = t.toCharArray();<br>        Arrays.sort(charS);<br>        Arrays.sort(charT);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(charS[i] != charT[i])&#123;<br>                <span class="hljs-keyword">return</span> charT[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> charT[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h2><p>日期：<code>2020/12/19</code></p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 matrix = <br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,5,6]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[7,8,9]</span></span><br><span class="hljs-comment">]</span>,<br><br>原地旋转输入矩阵，使其变为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[7,4,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[8,5,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,6,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 matrix =<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[ 5, 1, 9,11]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[ 2, 4, 8,10]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[13, 3, 6, 7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,14,12,16]</span></span><br><span class="hljs-comment">]</span>, <br><br>原地旋转输入矩阵，使其变为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,13, 2, 5]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[14, 3, 4, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[12, 6, 8, 9]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[16, 7,10,11]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>首先将矩阵沿次对角线翻转，再沿着水平中心线上下翻转即可获得顺时针旋转90°的图像。</p><p>若第一步沿主对角翻转，则获得逆时针旋转90°的图像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n - i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>];<br>                matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - i - <span class="hljs-number">1</span>][j];<br>                matrix[n - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>每日一题</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具与软件列表</title>
    <link href="/2020/tool-list/"/>
    <url>/2020/tool-list/</url>
    
    <content type="html"><![CDATA[<p>本页面是一个关于个人常用的工具总结，包含了常用工具的名称、用途、下载地址或者链接，用于备份以及分享使用软件。强烈推荐或者常用软件会将名称加粗，列表不定时更新中！</p><a id="more"></a><h1 id="1、桌面应用程序"><a href="#1、桌面应用程序" class="headerlink" title="1、桌面应用程序"></a>1、桌面应用程序</h1><h2 id="1-1-文件处理"><a href="#1-1-文件处理" class="headerlink" title="1.1 文件处理"></a>1.1 文件处理</h2><h2 id="1-2-文档编辑"><a href="#1-2-文档编辑" class="headerlink" title="1.2 文档编辑"></a>1.2 文档编辑</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">下载</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Typora</strong></td><td style="text-align:center">Markdown 文本编辑器</td><td style="text-align:center"><a href="https://typora.io/#windows">官网下载</a></td><td style="text-align:center">√</td><td style="text-align:center">支持实时预览</td></tr></tbody></table></div><h2 id="1-3-音视频处理"><a href="#1-3-音视频处理" class="headerlink" title="1.3 音视频处理"></a>1.3 音视频处理</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">下载</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">MP3TAG</td><td style="text-align:center">MP3文件标签编辑工具</td><td style="text-align:center"><a href="https://www.mp3tag.de/en/dodownload.html">官网下载</a></td><td style="text-align:center">√</td><td style="text-align:center">支持批量编辑MP3的tag、支持文件切割与合并</td></tr><tr><td style="text-align:center">DaVinci Resolve</td><td style="text-align:center">视频剪辑软件</td><td style="text-align:center"><a href="http://www.blackmagicdesign.com/cn/products/davinciresolve/edit">官网下载</a></td><td style="text-align:center">√</td><td style="text-align:center">不仅免费，其非编功能也是非常强大专业</td></tr></tbody></table></div><h2 id="1-4-垃圾清理"><a href="#1-4-垃圾清理" class="headerlink" title="1.4 垃圾清理"></a>1.4 垃圾清理</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">下载</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>SpaceSniffer</strong></td><td style="text-align:center">通过使用树形图可视化布局查看磁盘空间占用的查看工具。</td><td style="text-align:center"><a href="http://www.uderzo.it/main_products/space_sniffer/download.html">官网下载</a></td><td style="text-align:center">×</td><td style="text-align:center">一款免费软件和便携式工具应用程序，让您了解文件夹和文件在磁盘上的结构。</td></tr></tbody></table></div><h2 id="1-5-其他"><a href="#1-5-其他" class="headerlink" title="1.5 其他"></a>1.5 其他</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">下载</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">QTTabBar</td><td style="text-align:center">通过选项卡和额外的文件夹视图扩展资源管理器</td><td style="text-align:center"><a href="http://qttabbar.wikidot.com/">官网下载</a></td><td style="text-align:center">√</td></tr></tbody></table></div><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="2、-在线应用程序"><a href="#2、-在线应用程序" class="headerlink" title="2、 在线应用程序"></a>2、 在线应用程序</h1><h2 id="2-1-文件处理"><a href="#2-1-文件处理" class="headerlink" title="2.1 文件处理"></a>2.1 文件处理</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">链接</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">Convertio</td><td style="text-align:center">将文件转换成任意格式</td><td style="text-align:center"><a href="https://convertio.co/zh/">点击跳转</a></td><td style="text-align:center">√</td></tr></tbody></table></div><h2 id="2-2-文档编辑"><a href="#2-2-文档编辑" class="headerlink" title="2.2 文档编辑"></a>2.2 文档编辑</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">链接</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">MaHua</td><td style="text-align:center">在线markdown编辑器</td><td style="text-align:center"><a href="http://mahua.jser.me/">点击跳转</a></td><td style="text-align:center">√</td><td style="text-align:center">支持不同MD文档的渲染主题、支持自定义CSS</td></tr></tbody></table></div><h2 id="2-3-图片资源"><a href="#2-3-图片资源" class="headerlink" title="2.3 图片资源"></a>2.3 图片资源</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">链接</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>iconfont</strong></td><td style="text-align:center">阿里巴巴矢量图标库</td><td style="text-align:center"><a href="https://www.iconfont.cn/">点击跳转</a></td><td style="text-align:center">√</td><td style="text-align:center">拥有大量矢量图标可以选择</td></tr></tbody></table></div><h2 id="2-4-可视化工具"><a href="#2-4-可视化工具" class="headerlink" title="2.4 可视化工具"></a>2.4 可视化工具</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th><th style="text-align:center">链接</th><th style="text-align:center">中文</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">chartblocks</td><td style="text-align:center">线上制图工具</td><td style="text-align:center"><a href="https://www.chartblocks.com/zh">点击跳转</a></td><td style="text-align:center">√</td><td style="text-align:center">世界上最简单的统计图生成器应用程序。几分钟内就可设计并共享统计图。</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>实用总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>网站</tag>
      
      <tag>应用</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《习惯的力量》读书笔记</title>
    <link href="/2020/note-the-power-of-habit/"/>
    <url>/2020/note-the-power-of-habit/</url>
    
    <content type="html"><![CDATA[<p>《习惯的力量》是一本具有开创性的著作！它将让你重新审视自己的习惯。2012年在美国出版，随即成为一本疯行全球的“习惯改造指南”。它融合了目前最顶级的神经学家、心理学家、社会学家、顶尖企业家和优秀市场营销人员关于习惯的最新认知，同时综合了国际一流企业：宝洁、谷歌、微软，世界顶尖大学：哈佛、耶鲁、剑桥和MIT关于“习惯的力量”的最新研究结果！你想知道的所有关于“改变习惯的秘密”，都将在这本书中找到答案。本书也成为了最受500强企业员工欢迎、提振人心、认知自我的最实用读本！</p><a id="more"></a><p><a href="https://book.douban.com/subject/20507212/">豆瓣链接</a></p><h1 id="1-个体的习惯"><a href="#1-个体的习惯" class="headerlink" title="1  个体的习惯"></a>1  个体的习惯</h1><h2 id="1-1-习惯是如何运作的"><a href="#1-1-习惯是如何运作的" class="headerlink" title="1.1 习惯是如何运作的"></a>1.1 习惯是如何运作的</h2><p>习惯的出现是因为大脑一直在寻找可以省力的方式。这样的大脑可以让我们不再思考基本的行为，例如行走。</p><p>习惯回路：暗示→惯常行为→奖赏→暗示</p><p>习惯性的决定是不需要消耗脑力的，但是也是有风险的。</p><h2 id="1-2-如何创造新习惯"><a href="#1-2-如何创造新习惯" class="headerlink" title="1.2 如何创造新习惯"></a>1.2 如何创造新习惯</h2><p>某种特定的暗示和奖励机制这两者可以激发人的新习惯。</p><p>基础规律：</p><ol><li>找出一种简单又明显的暗示</li><li>清楚地说明有哪些奖赏</li></ol><p>习惯强大的原因：能够创造出神经渴求</p><h2 id="1-3如何改变旧习惯"><a href="#1-3如何改变旧习惯" class="headerlink" title="1.3如何改变旧习惯"></a>1.3如何改变旧习惯</h2><p>通过改变习惯回路中的惯常行为来改变旧习惯。</p><p>坏习惯是永远都不可能被根除掉的，只能被替代。</p><p>要改变习惯，需要留住原有的暗示和奖励，插入新的惯常行为。</p><p>为了保持习惯，人们得相信改变时可能的。</p><h1 id="2-成功的组织机构的习惯"><a href="#2-成功的组织机构的习惯" class="headerlink" title="2 成功的组织机构的习惯"></a>2 成功的组织机构的习惯</h1><h2 id="2-1-核心习惯"><a href="#2-1-核心习惯" class="headerlink" title="2.1 核心习惯"></a>2.1 核心习惯</h2><p>核心习惯比起其他习惯在重塑商业和生活方式上更有影响力。</p><p>核心习惯说明成功并不需要做对每一件事情，而是要辨别出一些重要的优先因素，并将其变成有力的杠杆。</p><p>善用习惯在于了解核心习惯：最重要的习惯是那些自身变化后，会驱动和重塑其他行为模式的习惯。</p><p>打造能促成其他习惯蓬勃发展的架构。</p><h2 id="2-2-让意志力变成自发行为"><a href="#2-2-让意志力变成自发行为" class="headerlink" title="2.2 让意志力变成自发行为"></a>2.2 让意志力变成自发行为</h2><p>意志力是有限的，自发的、非强迫性的行为将消耗更少的意志力。</p><h2 id="2-3通过意外事件创造新习惯"><a href="#2-3通过意外事件创造新习惯" class="headerlink" title="2.3通过意外事件创造新习惯"></a>2.3通过意外事件创造新习惯</h2><p>一个精心构建的习惯可以创造令人惊喜的改变，同样，错误的习惯会带来灾难性的结果。</p><p>优秀的领导者会抓住危机来重塑组织习惯。</p><p>危机可以为我们提供机会，让我们做之前不能做的事。</p><h2 id="2-4-操纵与预测习惯"><a href="#2-4-操纵与预测习惯" class="headerlink" title="2.4 操纵与预测习惯"></a>2.4 操纵与预测习惯</h2><p>当遭遇到人生的重大事件时，习惯更容易发生改变。</p><p>我们对“熟悉”事物的偏好其实是神经活动的产物。</p><p>行为习惯可以将我们从每天不得不做的、无穷无尽的决定中解脱出来。</p><h2 id="3-社会的习惯"><a href="#3-社会的习惯" class="headerlink" title="3 社会的习惯"></a>3 社会的习惯</h2><h3 id="3-1社会运动的发生"><a href="#3-1社会运动的发生" class="headerlink" title="3.1社会运动的发生"></a>3.1社会运动的发生</h3><p>在社群中，人与人之间都是讲义气，这就是弱联系的社会习惯。</p><p>要想让一个理念拓展到社群之外，就必须让整个拓展过程能够自我推动。要让人们养成可以帮助他们找到自我方向的新习惯。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习惯的力量</tag>
      
      <tag>阅读</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode部分SQL习题（二）</title>
    <link href="/2020/sql-on-leetcode-2/"/>
    <url>/2020/sql-on-leetcode-2/</url>
    
    <content type="html"><![CDATA[<p>SQL是一种特定目的编程语言，用于管理关系数据库管理系统（RDBMS），或在关系流数据管理系统（RDSMS）中进行流处理。<br><a id="more"></a></p><h3 id="595-大的国家"><a href="#595-大的国家" class="headerlink" title="595. 大的国家"></a><a href="https://leetcode-cn.com/problems/big-countries/">595. 大的国家</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>这里有张 World 表</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-----------------+------------+------------+--------------+---------------+<br>|<span class="hljs-string"> name            </span>|<span class="hljs-string"> continent  </span>|<span class="hljs-string"> area       </span>|<span class="hljs-string"> population   </span>|<span class="hljs-string"> gdp           </span>|<br>+-----------------+------------+------------+--------------+---------------+<br>|<span class="hljs-string"> Afghanistan     </span>|<span class="hljs-string"> Asia       </span>|<span class="hljs-string"> 652230     </span>|<span class="hljs-string"> 25500100     </span>|<span class="hljs-string"> 20343000      </span>|<br>|<span class="hljs-string"> Albania         </span>|<span class="hljs-string"> Europe     </span>|<span class="hljs-string"> 28748      </span>|<span class="hljs-string"> 2831741      </span>|<span class="hljs-string"> 12960000      </span>|<br>|<span class="hljs-string"> Algeria         </span>|<span class="hljs-string"> Africa     </span>|<span class="hljs-string"> 2381741    </span>|<span class="hljs-string"> 37100000     </span>|<span class="hljs-string"> 188681000     </span>|<br>|<span class="hljs-string"> Andorra         </span>|<span class="hljs-string"> Europe     </span>|<span class="hljs-string"> 468        </span>|<span class="hljs-string"> 78115        </span>|<span class="hljs-string"> 3712000       </span>|<br>|<span class="hljs-string"> Angola          </span>|<span class="hljs-string"> Africa     </span>|<span class="hljs-string"> 1246700    </span>|<span class="hljs-string"> 20609294     </span>|<span class="hljs-string"> 100990000     </span>|<br>+-----------------+------------+------------+--------------+---------------+<br></code></pre></td></tr></table></figure><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------------+</span>-------------<span class="hljs-code">+--------------+</span><br>| name         | population  | area         |<br><span class="hljs-code">+--------------+</span>-------------<span class="hljs-code">+--------------+</span><br>| Afghanistan  | 25500100    | 652230       |<br>| Algeria      | 37100000    | 2381741      |<br><span class="hljs-code">+--------------+</span>-------------<span class="hljs-code">+--------------+</span><br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT name, population, area<br>FROM World<br>WHERE area &gt; 3000000<br>    OR population &gt; 25000000 <br></code></pre></td></tr></table></figure><h3 id="596-超过5名学生的课"><a href="#596-超过5名学生的课" class="headerlink" title="596. 超过5名学生的课"></a><a href="https://leetcode-cn.com/problems/classes-more-than-5-students/">596. 超过5名学生的课</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>有一个courses 表 ，有: student (学生) 和 class (课程)。</p><p>请列出所有超过或等于5名学生的课。</p><p>例如,表:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+---------+------------+<br>|<span class="hljs-string"> student </span>|<span class="hljs-string"> class      </span>|<br>+---------+------------+<br>|<span class="hljs-string"> A       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> B       </span>|<span class="hljs-string"> English    </span>|<br>|<span class="hljs-string"> C       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> D       </span>|<span class="hljs-string"> Biology    </span>|<br>|<span class="hljs-string"> E       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> F       </span>|<span class="hljs-string"> Computer   </span>|<br>|<span class="hljs-string"> G       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> H       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> I       </span>|<span class="hljs-string"> Math       </span>|<br>+---------+------------+<br></code></pre></td></tr></table></figure><p>应该输出:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span><br>| class   |<br><span class="hljs-code">+---------+</span><br>| Math    |<br><span class="hljs-code">+---------+</span><br></code></pre></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT class<br>FROM <br>(<br>    SELECT class, COUNT(DISTINCT student) AS cnt<br>    FROM courses<br>    GROUP BY class<br>)AS temp<br>WHERE cnt &gt;&#x3D; 5 <br></code></pre></td></tr></table></figure><h3 id="601-体育馆的人流量"><a href="#601-体育馆的人流量" class="headerlink" title="601. 体育馆的人流量"></a><a href="https://leetcode-cn.com/problems/human-traffic-of-stadium/">601. 体育馆的人流量</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)。</p><p>请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。</p><p>例如，表 stadium：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------+------------+-----------+<br>|<span class="hljs-string"> id   </span>|<span class="hljs-string"> visit_date </span>|<span class="hljs-string"> people    </span>|<br>+------+------------+-----------+<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> 2017-01-01 </span>|<span class="hljs-string"> 10        </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> 2017-01-02 </span>|<span class="hljs-string"> 109       </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> 2017-01-03 </span>|<span class="hljs-string"> 150       </span>|<br>|<span class="hljs-string"> 4    </span>|<span class="hljs-string"> 2017-01-04 </span>|<span class="hljs-string"> 99        </span>|<br>|<span class="hljs-string"> 5    </span>|<span class="hljs-string"> 2017-01-05 </span>|<span class="hljs-string"> 145       </span>|<br>|<span class="hljs-string"> 6    </span>|<span class="hljs-string"> 2017-01-06 </span>|<span class="hljs-string"> 1455      </span>|<br>|<span class="hljs-string"> 7    </span>|<span class="hljs-string"> 2017-01-07 </span>|<span class="hljs-string"> 199       </span>|<br>|<span class="hljs-string"> 8    </span>|<span class="hljs-string"> 2017-01-08 </span>|<span class="hljs-string"> 188       </span>|<br>+------+------------+-----------+<br></code></pre></td></tr></table></figure><p>对于上面的示例数据，输出为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------+</span>------------<span class="hljs-code">+-----------+</span><br>| id   | visit<span class="hljs-emphasis">_date | people    |</span><br><span class="hljs-emphasis">+------+------------+-----------+</span><br><span class="hljs-emphasis">| 5    | 2017-01-05 | 145       |</span><br><span class="hljs-emphasis">| 6    | 2017-01-06 | 1455      |</span><br><span class="hljs-emphasis">| 7    | 2017-01-07 | 199       |</span><br><span class="hljs-emphasis">| 8    | 2017-01-08 | 188       |</span><br><span class="hljs-emphasis">+------+------------+-----------+</span><br></code></pre></td></tr></table></figure><p>提示：<br>每天只有一行记录，日期随着 id 的增加而增加。</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT A.*<br>FROM stadium AS A, stadium AS B, stadium AS C<br>WHERE   A.people &gt;&#x3D; 100 AND B.people &gt;&#x3D; 100 AND C.people &gt;&#x3D; 100<br>    AND(<br>        (A.id - B.id &#x3D; -1 AND B.id - C.id &#x3D; -1)<br>        OR(A.id - B.id &#x3D; 1 AND A.id - C.id &#x3D; -1)<br>        OR(A.id - B.id &#x3D; 1 AND A.id - C.id &#x3D; 2)<br>    )<br>ORDER BY A.id<br></code></pre></td></tr></table></figure><h3 id="620-有趣的电影"><a href="#620-有趣的电影" class="headerlink" title="620. 有趣的电影"></a><a href="https://leetcode-cn.com/problems/not-boring-movies/">620. 有趣的电影</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p><p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。</p><p>例如，下表 cinema:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+---------+-----------+--------------+-----------+<br>|<span class="hljs-string">   id    </span>|<span class="hljs-string"> movie     </span>|<span class="hljs-string">  description </span>|<span class="hljs-string">  rating   </span>|<br>+---------+-----------+--------------+-----------+<br>|<span class="hljs-string">   1     </span>|<span class="hljs-string"> War       </span>|<span class="hljs-string">   great 3D   </span>|<span class="hljs-string">   8.9     </span>|<br>|<span class="hljs-string">   2     </span>|<span class="hljs-string"> Science   </span>|<span class="hljs-string">   fiction    </span>|<span class="hljs-string">   8.5     </span>|<br>|<span class="hljs-string">   3     </span>|<span class="hljs-string"> irish     </span>|<span class="hljs-string">   boring     </span>|<span class="hljs-string">   6.2     </span>|<br>|<span class="hljs-string">   4     </span>|<span class="hljs-string"> Ice song  </span>|<span class="hljs-string">   Fantacy    </span>|<span class="hljs-string">   8.6     </span>|<br>|<span class="hljs-string">   5     </span>|<span class="hljs-string"> House card</span>|<span class="hljs-string">   Interesting</span>|<span class="hljs-string">   9.1     </span>|<br>+---------+-----------+--------------+-----------+<br></code></pre></td></tr></table></figure><p>对于上面的例子，则正确的输出是为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span>-----------<span class="hljs-code">+--------------+</span>-----------+<br>|   id    | movie     |  description |  rating   |<br><span class="hljs-code">+---------+</span>-----------<span class="hljs-code">+--------------+</span>-----------+<br>|   5     | House card|   Interesting|   9.1     |<br>|   1     | War       |   great 3D   |   8.9     |<br><span class="hljs-code">+---------+</span>-----------<span class="hljs-code">+--------------+</span>-----------+<br></code></pre></td></tr></table></figure><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM cinema<br>WHERE id % 2 &#x3D; 1 <br>    AND description !&#x3D; &#39;boring&#39;<br>ORDER BY rating DESC<br></code></pre></td></tr></table></figure><h3 id="626-换座位"><a href="#626-换座位" class="headerlink" title="626. 换座位"></a><a href="https://leetcode-cn.com/problems/exchange-seats/">626. 换座位</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 id 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span>---------+<br>|    id   | student |<br><span class="hljs-code">+---------+</span>---------+<br>|    1    | Abbot   |<br>|    2    | Doris   |<br>|    3    | Emerson |<br>|    4    | Green   |<br>|    5    | Jeames  |<br><span class="hljs-code">+---------+</span>---------+<br></code></pre></td></tr></table></figure><p>假如数据输入的是上表，则输出结果如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span>---------+<br>|    id   | student |<br><span class="hljs-code">+---------+</span>---------+<br>|    1    | Doris   |<br>|    2    | Abbot   |<br>|    3    | Green   |<br>|    4    | Emerson |<br>|    5    | Jeames  |<br><span class="hljs-code">+---------+</span>---------+<br></code></pre></td></tr></table></figure><p>注意：</p><p>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>    (CASE<br>        WHEN id % 2 !&#x3D; 0 AND id !&#x3D; counts THEN id + 1<br>        WHEN id % 2 !&#x3D; 0 AND id &#x3D; counts THEN id<br>        ELSE id - 1<br>    END) AS id,<br>    student<br>FROM<br>    seat,<br>    (SELECT<br>        COUNT(*) AS counts<br>    FROM<br>        seat) AS seat_counts<br>ORDER BY id ASC<br></code></pre></td></tr></table></figure><h3 id="627-交换工资"><a href="#627-交换工资" class="headerlink" title="627. 交换工资"></a><a href="https://leetcode-cn.com/problems/swap-salary/">627. 交换工资</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。</p><p>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。</p><p>例如：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> id   </span>|<span class="hljs-string"> name </span>|<span class="hljs-string"> sex  </span>|<span class="hljs-string"> salary </span>|<br>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ------ </span>|<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> A    </span>|<span class="hljs-string"> m    </span>|<span class="hljs-string"> 2500   </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> B    </span>|<span class="hljs-string"> f    </span>|<span class="hljs-string"> 1500   </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> C    </span>|<span class="hljs-string"> m    </span>|<span class="hljs-string"> 5500   </span>|<br>|<span class="hljs-string"> 4    </span>|<span class="hljs-string"> D    </span>|<span class="hljs-string"> f    </span>|<span class="hljs-string"> 500    </span>|<br></code></pre></td></tr></table></figure><br>运行你所编写的更新语句之后，将会得到以下表:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> id   </span>|<span class="hljs-string"> name </span>|<span class="hljs-string"> sex  </span>|<span class="hljs-string"> salary </span>|<br>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ------ </span>|<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> A    </span>|<span class="hljs-string"> f    </span>|<span class="hljs-string"> 2500   </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> B    </span>|<span class="hljs-string"> m    </span>|<span class="hljs-string"> 1500   </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> C    </span>|<span class="hljs-string"> f    </span>|<span class="hljs-string"> 5500   </span>|<br>|<span class="hljs-string"> 4    </span>|<span class="hljs-string"> D    </span>|<span class="hljs-string"> m    </span>|<span class="hljs-string"> 500    </span>|<br></code></pre></td></tr></table></figure></p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE salary<br>SET sex &#x3D; CASE sex<br>    WHEN &#39;f&#39; THEN &#39;m&#39;<br>    ELSE &#39;f&#39;<br>    END<br></code></pre></td></tr></table></figure><h3 id="1179-重新格式化部门表"><a href="#1179-重新格式化部门表" class="headerlink" title="1179. 重新格式化部门表"></a><a href="https://leetcode-cn.com/problems/reformat-department-table/">1179. 重新格式化部门表</a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>部门表 Department：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------+</span>---------+<br>| Column Name   | Type    |<br><span class="hljs-code">+---------------+</span>---------+<br>| id            | int     |<br>| revenue       | int     |<br>| month         | varchar |<br><span class="hljs-code">+---------------+</span>---------+<br></code></pre></td></tr></table></figure><p>(id, month) 是表的联合主键。<br>这个表格有关于每个部门每月收入的信息。<br>月份（month）可以取下列值 [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”]。</p><p>编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。</p><p>查询结果格式如下面的示例所示：</p><p>Department 表：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------+---------+-------+<br>|<span class="hljs-string"> id   </span>|<span class="hljs-string"> revenue </span>|<span class="hljs-string"> month </span>|<br>+------+---------+-------+<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> 8000    </span>|<span class="hljs-string"> Jan   </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> 9000    </span>|<span class="hljs-string"> Jan   </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> 10000   </span>|<span class="hljs-string"> Feb   </span>|<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> 7000    </span>|<span class="hljs-string"> Feb   </span>|<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> 6000    </span>|<span class="hljs-string"> Mar   </span>|<br>+------+---------+-------+<br></code></pre></td></tr></table></figure><p>查询得到的结果表：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------+-------------+-------------+-------------+-----+-------------+<br>|<span class="hljs-string"> id   </span>|<span class="hljs-string"> Jan_Revenue </span>|<span class="hljs-string"> Feb_Revenue </span>|<span class="hljs-string"> Mar_Revenue </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> Dec_Revenue </span>|<br>+------+-------------+-------------+-------------+-----+-------------+<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> 8000        </span>|<span class="hljs-string"> 7000        </span>|<span class="hljs-string"> 6000        </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> null        </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> 9000        </span>|<span class="hljs-string"> null        </span>|<span class="hljs-string"> null        </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> null        </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> null        </span>|<span class="hljs-string"> 10000       </span>|<span class="hljs-string"> null        </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> null        </span>|<br>+------+-------------+-------------+-------------+-----+-------------+<br></code></pre></td></tr></table></figure><p>注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。</p><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id,<br>SUM(CASE month WHEN &#39;Jan&#39; THEN revenue END) AS &#39;Jan_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Feb&#39; THEN revenue END) AS &#39;Feb_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Mar&#39; THEN revenue END) AS &#39;Mar_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Apr&#39; THEN revenue END) AS &#39;Apr_Revenue&#39;,<br>SUM(CASE month WHEN &#39;May&#39; THEN revenue END) AS &#39;May_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Jun&#39; THEN revenue END) AS &#39;Jun_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Jul&#39; THEN revenue END) AS &#39;Jul_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Aug&#39; THEN revenue END) AS &#39;Aug_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Sep&#39; THEN revenue END) AS &#39;Sep_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Oct&#39; THEN revenue END) AS &#39;Oct_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Nov&#39; THEN revenue END) AS &#39;Nov_Revenue&#39;,<br>SUM(CASE month WHEN &#39;Dec&#39; THEN revenue END) AS &#39;Dec_Revenue&#39;<br>FROM Department<br>GROUP BY id<br>ORDER BY id<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode部分SQL习题（一）</title>
    <link href="/2020/sql-on-leetcode/"/>
    <url>/2020/sql-on-leetcode/</url>
    
    <content type="html"><![CDATA[<p>SQL是一种特定目的编程语言，用于管理关系数据库管理系统（RDBMS），或在关系流数据管理系统（RDSMS）中进行流处理。<br><a id="more"></a></p><h3 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a>175. 组合两个表</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">表1: Person<br><span class="hljs-code">+-------------+</span>---------+<br>| 列名         | 类型     |<br><span class="hljs-code">+-------------+</span>---------+<br>| PersonId    | int     |<br>| FirstName   | varchar |<br>| LastName    | varchar |<br><span class="hljs-code">+-------------+</span>---------+<br>PersonId 是上表主键<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">表2: Address<br><span class="hljs-code">+-------------+</span>---------+<br>| 列名         | 类型    |<br><span class="hljs-code">+-------------+</span>---------+<br>| AddressId   | int     |<br>| PersonId    | int     |<br>| City        | varchar |<br>| State       | varchar |<br><span class="hljs-code">+-------------+</span>---------+<br>AddressId 是上表主键<br></code></pre></td></tr></table></figure><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：<br><code>FirstName, LastName, City, State</code></p><p>来源：<a href="https://leetcode-cn.com/problems/combine-two-tables">LeetCode</a></p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT FirstName, LastName, City, State<br>FROM Person<br>LEFT JOIN Address<br>ON Person.PersonId &#x3D; Address.PersonId<br></code></pre></td></tr></table></figure><h3 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a>176. 第二高的薪水</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>--------+<br>| Id | Salary |<br><span class="hljs-code">+----+</span>--------+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br><span class="hljs-code">+----+</span>--------+<br></code></pre></td></tr></table></figure><br>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------------+</span><br>| SecondHighestSalary |<br><span class="hljs-code">+---------------------+</span><br>| 200                 |<br><span class="hljs-code">+---------------------+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/second-highest-salary">LeetCode</a></p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>(<br>SELECT DISTINCT Salary<br>FROM Employee <br>ORDER BY Salary DESC<br>LIMIT 1 OFFSET 1<br>)<br>AS SecondHighestSalary<br></code></pre></td></tr></table></figure><h3 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a>177. 第N高的薪水</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>--------+<br>| Id | Salary |<br><span class="hljs-code">+----+</span>--------+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br><span class="hljs-code">+----+</span>--------+<br></code></pre></td></tr></table></figure><br>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------------+</span><br>| SecondHighestSalary |<br><span class="hljs-code">+---------------------+</span><br>| 200                 |<br><span class="hljs-code">+---------------------+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/nth-highest-salary">LeetCode</a></p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT<br>BEGIN<br>  SET N &#x3D; N - 1;<br>  RETURN (<br>      # Write your MySQL query statement below.<br>      SELECT salary<br>      FROM employee<br>      GROUP BY salary<br>      ORDER BY salary DESC<br>      LIMIT N, 1<br>  );<br>END<br></code></pre></td></tr></table></figure><h3 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a>178. 分数排名</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>编写一个 SQL 查询来实现分数排名。</p><p>如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-------+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Score </span>|<br>+----+-------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> 3.50  </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> 3.65  </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> 4.00  </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> 3.85  </span>|<br>|<span class="hljs-string"> 5  </span>|<span class="hljs-string"> 4.00  </span>|<br>|<span class="hljs-string"> 6  </span>|<span class="hljs-string"> 3.65  </span>|<br>+----+-------+<br></code></pre></td></tr></table></figure><br>例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------+------+<br>|<span class="hljs-string"> Score </span>|<span class="hljs-string"> Rank </span>|<br>+-------+------+<br>|<span class="hljs-string"> 4.00  </span>|<span class="hljs-string"> 1    </span>|<br>|<span class="hljs-string"> 4.00  </span>|<span class="hljs-string"> 1    </span>|<br>|<span class="hljs-string"> 3.85  </span>|<span class="hljs-string"> 2    </span>|<br>|<span class="hljs-string"> 3.65  </span>|<span class="hljs-string"> 3    </span>|<br>|<span class="hljs-string"> 3.65  </span>|<span class="hljs-string"> 3    </span>|<br>|<span class="hljs-string"> 3.50  </span>|<span class="hljs-string"> 4    </span>|<br>+-------+------+<br></code></pre></td></tr></table></figure><br>重要提示：对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 `Rank`<br>来源：<a href="https://leetcode-cn.com/problems/rank-scores">LeetCode</a></p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT Score,DENSE_RANK() OVER(ORDER BY Score DESC) AS &#96;Rank&#96;<br>FROM Scores <br></code></pre></td></tr></table></figure><h3 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a>180. 连续出现的数字</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-----+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Num </span>|<br>+----+-----+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string">  1  </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string">  1  </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string">  1  </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string">  2  </span>|<br>|<span class="hljs-string"> 5  </span>|<span class="hljs-string">  1  </span>|<br>|<span class="hljs-string"> 6  </span>|<span class="hljs-string">  2  </span>|<br>|<span class="hljs-string"> 7  </span>|<span class="hljs-string">  2  </span>|<br>+----+-----+<br></code></pre></td></tr></table></figure><br>例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------+</span><br>| ConsecutiveNums |<br><span class="hljs-code">+-----------------+</span><br>| 1               |<br><span class="hljs-code">+-----------------+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/consecutive-numbers">LeetCode</a></p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">方法一<br>SELECT DISTINCT A.Num AS ConsecutiveNums <br>FROM logs AS a<br>INNER JOIN logs AS B ON A.id+1 &#x3D; B.id AND A.Num &#x3D; B.Num<br>INNER JOIN logs AS C ON B.id+1 &#x3D; C.id AND B.Num &#x3D; C.Num<br><br>方法二<br>SELECT DISTINCT A.Num AS ConsecutiveNums <br>FROM logs AS A, logs AS B, logs AS C<br>WHERE A.id+1 &#x3D; B.id <br>    AND A.Num &#x3D; B.Num<br>    AND B.id+1 &#x3D; C.id <br>    AND B.Num &#x3D; C.Num<br></code></pre></td></tr></table></figure><h3 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a>181. 超过经理收入的员工</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-------+--------+-----------+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Name  </span>|<span class="hljs-string"> Salary </span>|<span class="hljs-string"> ManagerId </span>|<br>+----+-------+--------+-----------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> Joe   </span>|<span class="hljs-string"> 70000  </span>|<span class="hljs-string"> 3         </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> Henry </span>|<span class="hljs-string"> 80000  </span>|<span class="hljs-string"> 4         </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> Sam   </span>|<span class="hljs-string"> 60000  </span>|<span class="hljs-string"> NULL      </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> Max   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> NULL      </span>|<br>+----+-------+--------+-----------+<br></code></pre></td></tr></table></figure><br>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span><br>| Employee |<br><span class="hljs-code">+----------+</span><br>| Joe      |<br><span class="hljs-code">+----------+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers">LeetCode</a></p><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT A.Name As Employee <br>FROM Employee AS A, Employee AS B<br>WHERE A.MAnagerId &#x3D; B.Id<br>    AND A.Salary &gt; B.Salary<br></code></pre></td></tr></table></figure><h3 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a>182. 查找重复的电子邮箱</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</p><p>示例：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>---------+<br>| Id | Email   |<br><span class="hljs-code">+----+</span>---------+<br>| 1  | a@b.com |<br>| 2  | c@d.com |<br>| 3  | a@b.com |<br><span class="hljs-code">+----+</span>---------+<br></code></pre></td></tr></table></figure><br>根据以上输入，你的查询应返回以下结果：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span><br>| Email   |<br><span class="hljs-code">+---------+</span><br>| a@b.com |<br><span class="hljs-code">+---------+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/duplicate-emails">LeetCode</a></p><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT A.Email<br>FROM Person AS A, Person AS B<br>WHERE A.Email &#x3D; B.Email<br>    AND A.ID !&#x3D; B.Id<br></code></pre></td></tr></table></figure><h3 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a>183. 从不订购的客户</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Customers 表：<br><span class="hljs-code">+----+</span>-------+<br>| Id | Name  |<br><span class="hljs-code">+----+</span>-------+<br>| 1  | Joe   |<br>| 2  | Henry |<br>| 3  | Sam   |<br>| 4  | Max   |<br><span class="hljs-code">+----+</span>-------+<br>Orders 表：<br><span class="hljs-code">+----+</span>------------+<br>| Id | CustomerId |<br><span class="hljs-code">+----+</span>------------+<br>| 1  | 3          |<br>| 2  | 1          |<br><span class="hljs-code">+----+</span>------------+<br></code></pre></td></tr></table></figure><br>例如给定上述表格，你的查询应返回：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------+</span><br>| Customers |<br><span class="hljs-code">+-----------+</span><br>| Henry     |<br>| Max       |<br><span class="hljs-code">+-----------+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/customers-who-never-order">LeetCode</a></p><h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT Name AS Customers <br>FROM Customers <br>WHERE Id NOT IN <br>(<br>    SELECT CustomerId FROM Orders <br>)<br></code></pre></td></tr></table></figure><h3 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a>184. 部门工资最高的员工</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-------+--------+--------------+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Name  </span>|<span class="hljs-string"> Salary </span>|<span class="hljs-string"> DepartmentId </span>|<br>+----+-------+--------+--------------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> Joe   </span>|<span class="hljs-string"> 70000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> Jim   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> Henry </span>|<span class="hljs-string"> 80000  </span>|<span class="hljs-string"> 2            </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> Sam   </span>|<span class="hljs-string"> 60000  </span>|<span class="hljs-string"> 2            </span>|<br>|<span class="hljs-string"> 5  </span>|<span class="hljs-string"> Max   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> 1            </span>|<br>+----+-------+--------+--------------+<br></code></pre></td></tr></table></figure><br>Department 表包含公司所有部门的信息。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>----------+<br>| Id | Name     |<br><span class="hljs-code">+----+</span>----------+<br>| 1  | IT       |<br>| 2  | Sales    |<br><span class="hljs-code">+----+</span>----------+<br></code></pre></td></tr></table></figure><br>编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------------+</span>----------<span class="hljs-code">+--------+</span><br>| Department | Employee | Salary |<br><span class="hljs-code">+------------+</span>----------<span class="hljs-code">+--------+</span><br>| IT         | Max      | 90000  |<br>| IT         | Jim      | 90000  |<br>| Sales      | Henry    | 80000  |<br><span class="hljs-code">+------------+</span>----------<span class="hljs-code">+--------+</span><br></code></pre></td></tr></table></figure><br>解释：<br>Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</p><p>来源：<a href="https://leetcode-cn.com/problems/department-highest-salary">LeetCode</a></p><h4 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT Department.Name AS &#96;Department&#96;, Employee .Name AS &#96;Employee&#96;, Salary<br>FROM Employee<br>JOIN Department ON Employee.DepartmentId &#x3D; Department.Id<br>WHERE (Employee.DepartmentId , Salary) IN<br>(<br>    SELECT DepartmentId, MAX(Salary)<br>    FROM Employee<br>    GROUP BY DepartmentId<br>)<br></code></pre></td></tr></table></figure><h3 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a>185. 部门工资前三高的所有员工</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>Employee 表包含所有员工信息，每个员工有其对应的工号 Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-------+--------+--------------+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Name  </span>|<span class="hljs-string"> Salary </span>|<span class="hljs-string"> DepartmentId </span>|<br>+----+-------+--------+--------------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> Joe   </span>|<span class="hljs-string"> 85000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> Henry </span>|<span class="hljs-string"> 80000  </span>|<span class="hljs-string"> 2            </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> Sam   </span>|<span class="hljs-string"> 60000  </span>|<span class="hljs-string"> 2            </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> Max   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 5  </span>|<span class="hljs-string"> Janet </span>|<span class="hljs-string"> 69000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 6  </span>|<span class="hljs-string"> Randy </span>|<span class="hljs-string"> 85000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 7  </span>|<span class="hljs-string"> Will  </span>|<span class="hljs-string"> 70000  </span>|<span class="hljs-string"> 1            </span>|<br>+----+-------+--------+--------------+<br></code></pre></td></tr></table></figure><br>Department 表包含公司所有部门的信息。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>----------+<br>| Id | Name     |<br><span class="hljs-code">+----+</span>----------+<br>| 1  | IT       |<br>| 2  | Sales    |<br><span class="hljs-code">+----+</span>----------+<br></code></pre></td></tr></table></figure><br>编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------------+----------+--------+<br>|<span class="hljs-string"> Department </span>|<span class="hljs-string"> Employee </span>|<span class="hljs-string"> Salary </span>|<br>+------------+----------+--------+<br>|<span class="hljs-string"> IT         </span>|<span class="hljs-string"> Max      </span>|<span class="hljs-string"> 90000  </span>|<br>|<span class="hljs-string"> IT         </span>|<span class="hljs-string"> Randy    </span>|<span class="hljs-string"> 85000  </span>|<br>|<span class="hljs-string"> IT         </span>|<span class="hljs-string"> Joe      </span>|<span class="hljs-string"> 85000  </span>|<br>|<span class="hljs-string"> IT         </span>|<span class="hljs-string"> Will     </span>|<span class="hljs-string"> 70000  </span>|<br>|<span class="hljs-string"> Sales      </span>|<span class="hljs-string"> Henry    </span>|<span class="hljs-string"> 80000  </span>|<br>|<span class="hljs-string"> Sales      </span>|<span class="hljs-string"> Sam      </span>|<span class="hljs-string"> 60000  </span>|<br>+------------+----------+--------+<br></code></pre></td></tr></table></figure><br>解释：<br>IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。</p><p>来源：<a href="https://leetcode-cn.com/problems/department-top-three-salaries">LeetCode</a></p><h4 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT D.Name AS &#96;Department&#96;, E1.Name AS &#96;Employee&#96;, Salary<br>FROM Employee AS E1<br>JOIN Department AS D ON E1.DepartmentId &#x3D; D.Id<br>WHERE (<br>    SELECT COUNT(DISTINCT E2.Salary)<br>    FROM Employee AS E2<br>    WHERE E1.Salary &lt; E2.Salary<br>        AND E1.DepartmentId &#x3D; E2.DepartmentId<br>) &lt; 3<br></code></pre></td></tr></table></figure><h3 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a>196. 删除重复的电子邮箱</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------------------+<br>| Id | Email            |<br><span class="hljs-code">+----+</span>------------------+<br>| 1  | john@example.com |<br>| 2  | bob@example.com  |<br>| 3  | john@example.com |<br><span class="hljs-code">+----+</span>------------------+<br></code></pre></td></tr></table></figure><br>Id 是这个表的主键。<br>例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------------------+<br>| Id | Email            |<br><span class="hljs-code">+----+</span>------------------+<br>| 1  | john@example.com |<br>| 2  | bob@example.com  |<br><span class="hljs-code">+----+</span>------------------+<br></code></pre></td></tr></table></figure><br>提示：</p><ul><li>执行 SQL 之后，输出是整个 Person 表。</li><li>使用 delete 语句。<br>来源：<a href="https://leetcode-cn.com/problems/delete-duplicate-emails">LeetCode</a><h4 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE A FROM Person A,<br>    Person B<br>WHERE<br>    A.Email &#x3D; B.Email <br>    AND A.Id &gt; B.Id<br></code></pre></td></tr></table></figure></li></ul><h3 id="197-上升的温度"><a href="#197-上升的温度" class="headerlink" title="197. 上升的温度"></a>197. 上升的温度</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span>------------------<span class="hljs-code">+------------------+</span><br>| Id(INT) | RecordDate(DATE) | Temperature(INT) |<br><span class="hljs-code">+---------+</span>------------------<span class="hljs-code">+------------------+</span><br>|       1 |       2015-01-01 |               10 |<br>|       2 |       2015-01-02 |               25 |<br>|       3 |       2015-01-03 |               20 |<br>|       4 |       2015-01-04 |               30 |<br><span class="hljs-code">+---------+</span>------------------<span class="hljs-code">+------------------+</span><br></code></pre></td></tr></table></figure><br>例如，根据上述给定的 Weather 表格，返回如下 Id:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span><br>| Id |<br><span class="hljs-code">+----+</span><br>|  2 |<br>|  4 |<br><span class="hljs-code">+----+</span><br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/rising-temperature">LeetCode</a></p><h4 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT A.Id <br>FROM Weather AS A, Weather AS B<br>WHERE DATEDIFF(A.RecordDate, B.RecordDate) &#x3D; 1<br>    AND A.Temperature &gt; B.Temperature<br></code></pre></td></tr></table></figure><h3 id="262-行程和用户"><a href="#262-行程和用户" class="headerlink" title="262. 行程和用户"></a>262. 行程和用户</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>Trips 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 `(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-----------+-----------+---------+--------------------+----------+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Client_Id </span>|<span class="hljs-string"> Driver_Id </span>|<span class="hljs-string"> City_Id </span>|<span class="hljs-string">        Status      </span>|<span class="hljs-string">Request_at</span>|<br>+----+-----------+-----------+---------+--------------------+----------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string">     1     </span>|<span class="hljs-string">    10     </span>|<span class="hljs-string">    1    </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-01</span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string">     2     </span>|<span class="hljs-string">    11     </span>|<span class="hljs-string">    1    </span>|<span class="hljs-string"> cancelled_by_driver</span>|<span class="hljs-string">2013-10-01</span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string">     3     </span>|<span class="hljs-string">    12     </span>|<span class="hljs-string">    6    </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-01</span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string">     4     </span>|<span class="hljs-string">    13     </span>|<span class="hljs-string">    6    </span>|<span class="hljs-string"> cancelled_by_client</span>|<span class="hljs-string">2013-10-01</span>|<br>|<span class="hljs-string"> 5  </span>|<span class="hljs-string">     1     </span>|<span class="hljs-string">    10     </span>|<span class="hljs-string">    1    </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-02</span>|<br>|<span class="hljs-string"> 6  </span>|<span class="hljs-string">     2     </span>|<span class="hljs-string">    11     </span>|<span class="hljs-string">    6    </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-02</span>|<br>|<span class="hljs-string"> 7  </span>|<span class="hljs-string">     3     </span>|<span class="hljs-string">    12     </span>|<span class="hljs-string">    6    </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-02</span>|<br>|<span class="hljs-string"> 8  </span>|<span class="hljs-string">     2     </span>|<span class="hljs-string">    12     </span>|<span class="hljs-string">    12   </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-03</span>|<br>|<span class="hljs-string"> 9  </span>|<span class="hljs-string">     3     </span>|<span class="hljs-string">    10     </span>|<span class="hljs-string">    12   </span>|<span class="hljs-string">     completed      </span>|<span class="hljs-string">2013-10-03</span>|<span class="hljs-string"> </span><br>|<span class="hljs-string"> 10 </span>|<span class="hljs-string">     4     </span>|<span class="hljs-string">    13     </span>|<span class="hljs-string">    12   </span>|<span class="hljs-string"> cancelled_by_driver</span>|<span class="hljs-string">2013-10-03</span>|<br>+----+-----------+-----------+---------+--------------------+----------+<br></code></pre></td></tr></table></figure><br>Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----------+--------+--------+<br>|<span class="hljs-string"> Users_Id </span>|<span class="hljs-string"> Banned </span>|<span class="hljs-string">  Role  </span>|<br>+----------+--------+--------+<br>|<span class="hljs-string">    1     </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> client </span>|<br>|<span class="hljs-string">    2     </span>|<span class="hljs-string">   Yes  </span>|<span class="hljs-string"> client </span>|<br>|<span class="hljs-string">    3     </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> client </span>|<br>|<span class="hljs-string">    4     </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> client </span>|<br>|<span class="hljs-string">    10    </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> driver </span>|<br>|<span class="hljs-string">    11    </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> driver </span>|<br>|<span class="hljs-string">    12    </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> driver </span>|<br>|<span class="hljs-string">    13    </span>|<span class="hljs-string">   No   </span>|<span class="hljs-string"> driver </span>|<br>+----------+--------+--------+<br></code></pre></td></tr></table></figure><br>写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。</p><p>取消率的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------------+</span>-------------------+<br>|     Day    | Cancellation Rate |<br><span class="hljs-code">+------------+</span>-------------------+<br>| 2013-10-01 |       0.33        |<br>| 2013-10-02 |       0.00        |<br>| 2013-10-03 |       0.50        |<br><span class="hljs-code">+------------+</span>-------------------+<br></code></pre></td></tr></table></figure><br>来源：<a href="https://leetcode-cn.com/problems/trips-and-users">LeetCode</a></p><h4 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>    Request_at AS Day, <br>    ROUND(AVG(Status!&#x3D;&#39;completed&#39;), 2) AS &#39;Cancellation Rate&#39;<br>FROM Trips AS T<br>JOIN Users AS U1 ON T.Client_Id  &#x3D; U1.Users_Id AND U1.Banned &#x3D; &quot;No&quot;<br>JOIN Users AS U2 ON T.Driver_Id  &#x3D; U2.Users_Id AND U2.Banned &#x3D; &quot;No&quot;    <br>WHERE request_at BETWEEN &#39;2013-10-01&#39; AND &#39;2013-10-03&#39;<br>GROUP BY Request_at<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24种性格力量测试</title>
    <link href="/2020/character-strengths/"/>
    <url>/2020/character-strengths/</url>
    
    <content type="html"><![CDATA[<p>在哈佛幸福课第13讲中，提到了一种应用自身人格力量来获得积极心态、对抗逆境的方法。<br>VIA（行动价值协会）性格力量手册是由Seligman和Peterson提出，主张通过鉴别人的美德、力量与长处，并利用这些人格力量来获得积极的心态、实现自我和谐的奋斗旅程。</p><a id="more"></a>  <p>测试网站：<br><a href="https://www.viacharacter.org/character-strengths-via">Learn Your Character Strengths &amp; Personal Traits | VIA Institute</a><br><a href="https://types.yuzeli.com/survey/via240">24种人格力量测试(VIA) - 优势识别器_心理成长</a></p><p>我的测试结果</p><h4 id="1、Honesty丨坦诚"><a href="#1、Honesty丨坦诚" class="headerlink" title="1、Honesty丨坦诚"></a>1、Honesty丨坦诚</h4><p>Speaking the truth but more broadly presenting oneself in a genuine way and acting in a sincere way; being without pretense; taking responsibility for one’s feelings and actions.<br>你是个诚实的人,不止说实话,还会以很真实的态度生活和与别人交往。你是个实事求是的人,不会假装自己的情绪和状态,是个「真心」的人。</p><h4 id="2、Fairness丨公平"><a href="#2、Fairness丨公平" class="headerlink" title="2、Fairness丨公平"></a>2、Fairness丨公平</h4><p>Treating all people the same according to notions of fairness and justice; not letting feelings bias decisions about others; giving everyone a fair chance.<br>对所有人公平,是你坚持不变的原则。 你不会因为个人的感情,而影响你对别人做出有偏差的判断。 你给予每个人平等的机会。</p><h4 id="3、Humility丨谦逊"><a href="#3、Humility丨谦逊" class="headerlink" title="3、Humility丨谦逊"></a>3、Humility丨谦逊</h4><p>Letting one’s accomplishments speak for themselves; not regarding oneself as more special than one is.<br>你喜欢让自己的成就和行动为自己说话。 你不认为自己要比别人特殊,让事实说话，谦虚是你的特质。</p><h4 id="4、Gratitude-感恩"><a href="#4、Gratitude-感恩" class="headerlink" title="4、Gratitude|感恩"></a>4、Gratitude|感恩</h4><p>Being aware of and thankful for the good things that happen; taking time to express thanks.<br>你留意到发生在自己身上的好事,但从不会视为理所当然。由于你常常表达谢意,你身边的人都知道你是个懂得感恩的人。</p><h4 id="5、Kindness-友善"><a href="#5、Kindness-友善" class="headerlink" title="5、Kindness|友善"></a>5、Kindness|友善</h4><p>Doing favors and good deeds for others; helping them; taking care of them.<br>你乐于帮助别人，为他人做对他们有益的事情。 别人请你做事,你从不推搪。你享受为别人做好事,照顾他人，即使是那些人和你认识不深。</p><h4 id="6、Leadership-统率"><a href="#6、Leadership-统率" class="headerlink" title="6、Leadership|统率"></a>6、Leadership|统率</h4><p>Encouraging a group of which one is a member to get things done and at the same time maintain good relations within the group; organizing group activities and seeing that they happen.<br>你善于鼓励你所在的团队中的其它伙伴完成工作,但与此同时还能让每名组员和你有良好的关系。你善于筹划活动，让一件事实实在在的发生。</p><h4 id="7、Appreciation-of-Beauty-amp-Excellence-欣赏美与卓越"><a href="#7、Appreciation-of-Beauty-amp-Excellence-欣赏美与卓越" class="headerlink" title="7、Appreciation of Beauty &amp; Excellence|欣赏美与卓越"></a>7、Appreciation of Beauty &amp; Excellence|欣赏美与卓越</h4><p>Noticing and appreciating beauty, excellence, and/or skilled performance in various domains of life, from nature to art to mathematics to science to everyday experience.<br>在生命中的一切一切,从大自然、艺术、数学、科学以至日常生活体验,你都有注意到和欣赏到其美丽、优秀,和富技巧之处。</p><h4 id="8、Prudence-谨慎"><a href="#8、Prudence-谨慎" class="headerlink" title="8、Prudence|谨慎"></a>8、Prudence|谨慎</h4><p>Being careful about one’s choices; not taking undue risks; not saying or doing things that might later be regretted.<br>你这个人很小心,选择也是一贯的审慎。 你不会说些将来会令自己后悔的话,或是做会后悔的事。</p><h4 id="9、Love-深度交往"><a href="#9、Love-深度交往" class="headerlink" title="9、Love|深度交往"></a>9、Love|深度交往</h4><p>Valuing close relations with others, in particular those in which sharing &amp; caring are reciprocated; being close to people.<br>你重视和别人的亲密关系,特别是那些互相分享和关怀的关系。 那些给你最亲密感觉的人,他们同样感到跟你最亲密。</p><h4 id="10、Zest-热情"><a href="#10、Zest-热情" class="headerlink" title="10、Zest|热情"></a>10、Zest|热情</h4><p>Approaching life with excitement and energy; not doing things halfway or halfheartedly; living life as an adventure; feeling alive and activated.<br>无论做什么事,你都怀着兴奋的心情和干劲去做。 你做事不会半途而废,也不会觉得没劲。 对于你来说,生命是一场历险。</p><h4 id="11、Creativity-创意"><a href="#11、Creativity-创意" class="headerlink" title="11、Creativity|创意"></a>11、Creativity|创意</h4><p>Thinking of novel and productive ways to conceptualize and do things; includes artistic achievement but is not limited to it.<br>能够想出新方法做事是你拥有的重要特质。 如果有更好的方法,你决不会满足于用传统方法去做同样的事。</p><h4 id="12、Forgiveness-宽容"><a href="#12、Forgiveness-宽容" class="headerlink" title="12、Forgiveness|宽容"></a>12、Forgiveness|宽容</h4><p>Forgiving those who have done wrong; accepting others’ shortcomings; giving people a second chance; not being vengeful.<br>你宽恕那些开罪你的人,也经常给别人第二次机会。 你的左右铭是慈悲,而不是报复。</p><h4 id="13、Teamwork-团队精神"><a href="#13、Teamwork-团队精神" class="headerlink" title="13、Teamwork|团队精神"></a>13、Teamwork|团队精神</h4><p>Working well as a member of a group or team; being loyal to the group; doing one’s share.<br>作为团队的一份子,你的表现突出,是个忠心和热心的队员。 你对自己分内工作负责,并为团队的成功而努力。</p><h4 id="14、Love-of-learning-喜爱学习"><a href="#14、Love-of-learning-喜爱学习" class="headerlink" title="14、Love of learning|喜爱学习"></a>14、Love of learning|喜爱学习</h4><p>Mastering new skills, topics, and bodies of knowledge, whether on one’s own or formally; related to the strength of curiosity but goes beyond it to describe the tendency to add systematically to what one knows.<br>不管是在课堂上或自学,你都喜爱学习新事物的过程。与好奇心有相似之处，但是这个优势让你喜欢系统性地在自己已经有的知识以外去吸收学习。</p><h4 id="15、Judgment-判断力"><a href="#15、Judgment-判断力" class="headerlink" title="15、Judgment|判断力"></a>15、Judgment|判断力</h4><p>Thinking things through and examining them from all sides; not jumping to conclusions; being able to change one’s mind in light of evidence; weighing all evidence fairly.<br>能从多角度思考和考证事物是你重要的特质。 你不会妄下结论,只会根据实际的证据做决定。 你能够变通。</p><h4 id="16、Bravery-勇敢"><a href="#16、Bravery-勇敢" class="headerlink" title="16、Bravery|勇敢"></a>16、Bravery|勇敢</h4><p>Not shrinking from threat, challenge, difficulty, or pain; speaking up for what’s right even if there’s opposition; acting on convictions even if unpopular; includes physical bravery but is not limited to it.<br>你这个人无所畏惧,绝不会在威胁、挑战、困难或痛苦前畏缩。 即使面对反抗,你仍会为正义大声疾呼。 你会根据自己的信念而行动。</p><h4 id="17、Social-intelligence-社交智慧"><a href="#17、Social-intelligence-社交智慧" class="headerlink" title="17、Social intelligence|社交智慧"></a>17、Social intelligence|社交智慧</h4><p>Being aware of the motives/feelings of others and oneself; knowing what to do to fit into different social situations; knowing what makes other people tick.<br>你能轻松地察觉别人的动机和感受。 在不同的社交场合,你知道该做什么,才能使其他人感到自在。</p><h4 id="18、Self-Regulation-自我控制"><a href="#18、Self-Regulation-自我控制" class="headerlink" title="18、Self-Regulation|自我控制"></a>18、Self-Regulation|自我控制</h4><p>Regulating what one feels and does; being disciplined; controlling one’s appetites and emotions.<br>你自觉地控制自己的情绪与行为，是个自律的人。 你对自己的食量和情绪都很有自制力,不会反被它们支配。</p><h4 id="19、Humor-幽默"><a href="#19、Humor-幽默" class="headerlink" title="19、Humor|幽默"></a>19、Humor|幽默</h4><p>Liking to laugh and tease; bringing smiles to other people; seeing the light side; making (not necessarily telling) jokes.<br>你喜欢大笑和逗别人开心。 对你来说,为别人带来欢笑很重要。 在任何情况下,你都尝试去看事情轻松的一面。</p><h4 id="20、Curiosity-好奇心"><a href="#20、Curiosity-好奇心" class="headerlink" title="20、Curiosity|好奇心"></a>20、Curiosity|好奇心</h4><p>Taking an interest in ongoing experience for its own sake; finding subjects and topics fascinating; exploring and discovering.<br>你对任何事都感到好奇。 你经常发问,对所有话题和题目都感到着迷。 你喜欢探索和发掘新事物。</p><h4 id="21、Perspective-洞察力"><a href="#21、Perspective-洞察力" class="headerlink" title="21、Perspective|洞察力"></a>21、Perspective|洞察力</h4><p>Being able to provide wise counsel to others; having ways of looking at the world that make sense to oneself/others.<br>你的朋友常常认为你有独特的观察视角和能力。 他们重视你对事物的洞察力和分析,并向你寻求意见。 你具备对事物做解析并让自己和别人轻松理解的能力。</p><h4 id="22、Spirituality-灵性"><a href="#22、Spirituality-灵性" class="headerlink" title="22、Spirituality|灵性"></a>22、Spirituality|灵性</h4><p>Having coherent beliefs about the higher purpose and meaning of the universe; knowing where one fits within the larger scheme; having beliefs about the meaning of life that shape conduct and provide comfort.<br>你对祟高的人生目标和宇宙的意义有着强烈和贯彻的信念。 你知道自己怎样在大环境中作出配合。 你的信念塑造了你的行为,也成了你的慰藉之源。</p><h4 id="23、Hope-乐观"><a href="#23、Hope-乐观" class="headerlink" title="23、Hope|乐观"></a>23、Hope|乐观</h4><p>Expecting the best in the future and working to achieve it; believing that a good future is something that can be brought about.<br>你对未来有最好的期望,并为此努力达成心愿。 你相信未来是掌握在你手中。</p><h4 id="24、Perseverance-坚毅"><a href="#24、Perseverance-坚毅" class="headerlink" title="24、Perseverance|坚毅"></a>24、Perseverance|坚毅</h4><p>Finishing what one starts; persevering in a course of action in spite of obstacles; “getting it out the door”; taking pleasure in completing tasks.<br>你努力完成自己开展的工作。 无论怎样的工作,你都会尽力准时完成。 工作时,你不会分心,而且在完成工作的过程中获得满足感。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈佛幸福课</tag>
      
      <tag>性格力量测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法总结</title>
    <link href="/2020/sorting-algorithm/"/>
    <url>/2020/sorting-algorithm/</url>
    
    <content type="html"><![CDATA[<p>排序算法是最基础的算法之一，可以使用的场景也很多。不同的排序算法有不同的优缺点，这里列举了八种常用的排序算法。<br><a id="more"></a><br>各个算法的复杂度和稳定性：</p><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(n^{\frac{3}{2}})$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(nlog_{2}n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(nlog_{2}n)$</td><td>$O(log_{2}n)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(nlog_{2}n)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>基数排序</td><td>$O(n*k)$</td><td>$O(n+k)$</td><td>稳定</td></tr></tbody></table></div><blockquote><p>本页面所有代码均使用C实现，使用<a href="https://leetcode-cn.com/problems/sort-an-array/">Leetcode</a>的数组排序进行测试（题目：给你一个整数数组 nums，请你将该数组升序排列）,部分不够高效的排序算法在进行大量数据排序时会超出时间限制。部分排序算法参考<a href="https://leetcode-cn.com/problems/sort-an-array/solution/">排序数组-题解</a></p></blockquote><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><h4 id="1-1、步骤"><a href="#1-1、步骤" class="headerlink" title="1.1、步骤"></a>1.1、步骤</h4><ol><li>从头开始比较相邻元素，如果大小顺序错误则交换位置</li><li>往后移动继续比较，直到末尾（这时最大的元素应在末尾）</li><li>如果某一趟排序未进行交换操作则排序结束</li><li>忽略末尾已排序的元素，重复进行1与2直到排序完成</li></ol><h4 id="1-2、实现"><a href="#1-2、实现" class="headerlink" title="1.2、实现"></a>1.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    *returnSize = numsSize;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">bool</span> isFinished = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; numsSize - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j + <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">int</span> temp = nums[j];<br>                nums[j] = nums[j + <span class="hljs-number">1</span>];<br>                nums[j + <span class="hljs-number">1</span>] = temp;<br>                isFinished = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isFinished) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><h4 id="2-1、步骤"><a href="#2-1、步骤" class="headerlink" title="2.1、步骤"></a>2.1、步骤</h4><ol><li>遍历数组找出其中的最小元素</li><li>将最小元素放置到已排序部分队尾</li><li>剩余元素重复1于2直至排序完成</li></ol><h4 id="2-2、实现"><a href="#2-2、实现" class="headerlink" title="2.2、实现"></a>2.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    *returnSize = numsSize;<br>    <span class="hljs-keyword">int</span> i, j, min;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;<br>        min = i;<br>        <span class="hljs-keyword">for</span>(j = i; j &lt; numsSize; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[min])&#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        nums[i] = nums[min];<br>        nums[min] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h3><h4 id="3-1、步骤"><a href="#3-1、步骤" class="headerlink" title="3.1、步骤"></a>3.1、步骤</h4><p>在要排序的一组数中，假定前n-1个数已经是有序序列</p><ol><li>找到第n个数插入有序序列的位置k</li><li>将k到n-1位的数后移一位，第k位的值赋值位第n位的值</li><li>重复1与2直到排序完成</li></ol><h4 id="3-2、实现"><a href="#3-2、实现" class="headerlink" title="3.2、实现"></a>3.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    *returnSize = numsSize;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; numsSize; i++)&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( j &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; nums[j])&#123;<br>            nums[j + <span class="hljs-number">1</span>] = nums[j];<br>            j--;<br>        &#125;<br>        nums[j + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h3><h4 id="4-1、步骤"><a href="#4-1、步骤" class="headerlink" title="4.1、步骤"></a>4.1、步骤</h4><ol><li>取一个小于n的步长$d_1$，将带待排序元素分为$d_1$组</li><li>对每一组分别进行插入排序</li><li>取第二个步长$d_2$($d_1$&gt;$d_2$),重复1与2直至排序完成</li></ol><h4 id="4-2、实现"><a href="#4-2、实现" class="headerlink" title="4.2、实现"></a>4.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    *returnSize = numsSize;<br>    <span class="hljs-keyword">int</span> gap, i, j;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span> (gap = numsSize / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> (i = gap; i &lt; numsSize; i++) &#123;<br>            temp = nums[i];<br>            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; temp; j -= gap)<br>                nums[j + gap] = nums[j];<br>            nums[j + gap] = temp;<br>        &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、2路-归并排序"><a href="#5、2路-归并排序" class="headerlink" title="5、2路-归并排序"></a>5、2路-归并排序</h3><h4 id="5-1、步骤"><a href="#5-1、步骤" class="headerlink" title="5.1、步骤"></a>5.1、步骤</h4><p>假定待排序表中n个元素为n个有序的子表，归并是指将两个有序表合成为一个新的有序表</p><ol><li>将子表两两归并，得到n/2个长度为2或1的有序子表</li><li>重复1直至排序完成</li></ol><h4 id="5-2、实现"><a href="#5-2、实现" class="headerlink" title="5.2、实现"></a>5.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> midIndex, <span class="hljs-keyword">int</span> endIndex, <span class="hljs-keyword">int</span>* sorted)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> left = startIndex;<br>    <span class="hljs-keyword">int</span> right = midIndex + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> sortedIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= midIndex &amp;&amp; right &lt;= endIndex) &#123;<br>        <span class="hljs-keyword">if</span> (nums[left] &lt; nums[right]) &#123;<br>            sorted[sortedIndex++] = nums[left++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sorted[sortedIndex++] = nums[right++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= midIndex) &#123;<br>        sorted[sortedIndex++] = nums[left++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (right &lt;= endIndex) &#123;<br>        sorted[sortedIndex++] = nums[right++];<br>    &#125;<br>    sortedIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (startIndex &lt;= endIndex) &#123;<br>        nums[startIndex++] = sorted[sortedIndex++];<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> endIndex, <span class="hljs-keyword">int</span>* sorted)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (endIndex &lt;= startIndex) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> midIndex = (startIndex + endIndex) / <span class="hljs-number">2</span>;<br><br>    MergeSort(nums, startIndex, midIndex, sorted);<br>    MergeSort(nums, midIndex + <span class="hljs-number">1</span>, endIndex, sorted);<br>    <br>    Merge(nums, startIndex, midIndex, endIndex, sorted);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>* sorted = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * numsSize);<br>    MergeSort(nums, <span class="hljs-number">0</span>, numsSize - <span class="hljs-number">1</span>, sorted);<br>    <span class="hljs-built_in">free</span>(sorted);<br>    *returnSize = numsSize;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h3><h4 id="6-1、步骤"><a href="#6-1、步骤" class="headerlink" title="6.1、步骤"></a>6.1、步骤</h4><p>快速排序是对冒泡排序的一种改进算法。</p><ol><li>在待排序表中任取一个元素p作为基准</li><li>通过一趟排序将待排序表分为两个子表，其中一个子表所有元素小于p，另一个子表多有元素大于p</li><li>递归地对上面两个字表进行1与2直至排序完成</li></ol><h4 id="6-2、实现"><a href="#6-2、实现" class="headerlink" title="6.2、实现"></a>6.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* Nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">int</span> i=left,j=right,temp=Nums[left];<br>        <span class="hljs-keyword">while</span>(i!=j)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;Nums[j]&gt;temp)<br>                j--;<br>        <span class="hljs-keyword">if</span>(i&lt;j)<br>            Nums[i++]=Nums[j];<br>        <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;Nums[i]&lt;temp)<br>            i++;<br>        <span class="hljs-keyword">if</span>(i&lt;j)<br>            Nums[j--]=Nums[i];<br>        &#125;<br>        Nums[i]=temp;<span class="hljs-comment">//</span><br>        quicksort(Nums,left,i<span class="hljs-number">-1</span>);<br>        quicksort(Nums,i+<span class="hljs-number">1</span>,right);<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    *returnSize=numsSize;<br>    quicksort(nums,<span class="hljs-number">0</span>,numsSize<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、堆排序"><a href="#7、堆排序" class="headerlink" title="7、堆排序"></a>7、堆排序</h3><h4 id="7-1、步骤"><a href="#7-1、步骤" class="headerlink" title="7.1、步骤"></a>7.1、步骤</h4><p>在排序的过程中，将待排序表看成是一棵完全二叉树的顺序存储结构，利用玩完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（最小）的元素。</p><ol><li>用待排序表构建初始堆</li><li>输出堆顶元素</li><li>用剩余元素构建大顶堆（小顶堆），重复1与2直至排序完成</li></ol><h4 id="7-2、实现"><a href="#7-2、实现" class="headerlink" title="7.2、实现"></a>7.2、实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AdjustDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> numsSize)</span></span>&#123;   <span class="hljs-comment">//向下调整</span><br>    <span class="hljs-keyword">int</span> temp = nums[a];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>;i&lt;numsSize;i=<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;numsSize &amp;&amp; nums[i+<span class="hljs-number">1</span>]&gt;nums[i])&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp &gt;= nums[i])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        nums[a] = nums[i];<br>        a = i;<br>    &#125;<br>    nums[a] = temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    (*returnSize) = numsSize;<br>    <span class="hljs-keyword">if</span>(numsSize &lt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numsSize/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;          <span class="hljs-comment">//建大根堆</span><br>        AdjustDown(nums,i,numsSize);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numsSize<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;       <span class="hljs-comment">//排序</span><br>        <span class="hljs-keyword">int</span> temp = nums[<span class="hljs-number">0</span>];<br>        nums[<span class="hljs-number">0</span>] = nums[i];<br>        nums[i] = temp;<br>        AdjustDown(nums,<span class="hljs-number">0</span>,i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、基数排序"><a href="#8、基数排序" class="headerlink" title="8、基数排序"></a>8、基数排序</h3><p>基数排序是一种特别的排序方法，它采用多关键字排序思想，借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先排序和最低位优先排序。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C语言</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式总结</title>
    <link href="/2020/regular-expression/"/>
    <url>/2020/regular-expression/</url>
    
    <content type="html"><![CDATA[<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。<br><a id="more"></a></p><p>正则表达式经常会在项目中用到，但是通常不是很直观，不易理解。为了方便查阅便记录了一些常用的正则表达式。</p><blockquote><p>正则表达式：<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式–维基百科</a>、<a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式–语法|菜鸟教程</a><br>正则可视化网站：<a href="http://wangwl.net/static/projects/visualRegex">正则可视化</a>、<a href="https://regexper.com/">Regexper</a>、<a href="https://www.debuggex.com/">Debuggex</a>、<a href="https://jex.im/regulex">Regulex</a><br>正则表达式测试：<a href="https://tool.oschina.net/regex#">在线正则表达式测试</a>、<a href="http://c.runoob.com/front-end/854">正则表达式在线测试丨菜鸟工具</a></p><p>本页面正则可视化均使用Regulex，若正则可视化显示错误请刷新页面或者点击图片右下角前往Regulex查看</p></blockquote><h3 id="1、邮箱"><a href="#1、邮箱" class="headerlink" title="1、邮箱"></a>1、邮箱</h3><h4 id="1-1、常用邮箱"><a href="#1-1、常用邮箱" class="headerlink" title="1.1、常用邮箱"></a>1.1、常用邮箱</h4><p>只允许英文字母、数字、下划线、英文句号、以及中划线组成<br><code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)+$</code></p><iframe frameborder="0" width="100%" height="350" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E%5Ba-zA-Z0-9_-%5D%2B%40%5Ba-zA-Z0-9-%5D%2B(%5C.%5Ba-zA-Z0-9-%5D%2B)%2B%24"></iframe> <h4 id="1-2、常用邮箱2"><a href="#1-2、常用邮箱2" class="headerlink" title="1.2、常用邮箱2"></a>1.2、常用邮箱2</h4><p><code>^[\w_-]+(?:\.[\w_-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?$</code></p><iframe frameborder="0" width="100%" height="260" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E%5B%5Cw_-%5D%2B(%3F%3A%5C.%5B%5Cw_-%5D%2B)*%40(%3F%3A%5B%5Cw%5D(%3F%3A%5B%5Cw-%5D*%5B%5Cw%5D)%3F%5C.)%2B%5B%5Cw%5D(%3F%3A%5B%5Cw-%5D*%5B%5Cw%5D)%3F%24"></iframe> <h3 id="2、电话-手机号码"><a href="#2、电话-手机号码" class="headerlink" title="2、电话/手机号码"></a>2、电话/手机号码</h3><h4 id="2-1、电话"><a href="#2-1、电话" class="headerlink" title="2.1、电话"></a>2.1、电话</h4><p>XXX-XXXXXXX XXXX-XXXXXXXX 格式的固定电话<br><code>(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;8&#125;</code></p><iframe frameborder="0" width="100%" height="300" src="https://jex.im/regulex/#!embed=true&flags=&re=(%5C(%5Cd%7B3%2C4%7D%5C)%7C%5Cd%7B3%2C4%7D-%7C%5Cs)%3F%5Cd%7B8%7D"></iframe><h4 id="2-1、手机"><a href="#2-1、手机" class="headerlink" title="2.1、手机"></a>2.1、手机</h4><p>1XX XXXX XXXX的11位手机号<br><code>^1[^12]\d&#123;9&#125;$</code></p><iframe frameborder="0" width="100%" height="150" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E1%5B%5E12%5D%5Cd%7B9%7D%24"></iframe><h3 id="3、域名-URL"><a href="#3、域名-URL" class="headerlink" title="3、域名/URL"></a>3、域名/URL</h3><h4 id="3-1、通用"><a href="#3-1、通用" class="headerlink" title="3.1、通用"></a>3.1、通用</h4><p>支持所有的协议<br><code>[a-zA-z]+://[^\s]*</code></p><iframe frameborder="0" width="100%" height="190" src="https://jex.im/regulex/#!embed=true&flags=&re=%5Ba-zA-z%5D%2B%3A%2F%2F%5B%5E%5Cs%5D*"></iframe><h4 id="3-2、http-https协议"><a href="#3-2、http-https协议" class="headerlink" title="3.2、http/https协议"></a>3.2、http/https协议</h4><p><code>^((http:\/\/)|(https:\/\/))?([a-zA-Z0-9]([a-zA-Z0-9\-]&#123;0,61&#125;[a-zA-Z0-9])?\.)+[a-zA-Z]&#123;2,6&#125;(\/)</code></p><iframe frameborder="0" width="100%" height="420" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E((http%3A%5C%2F%5C%2F)%7C(https%3A%5C%2F%5C%2F))%3F(%5Ba-zA-Z0-9%5D(%5Ba-zA-Z0-9%5C-%5D%7B0%2C61%7D%5Ba-zA-Z0-9%5D)%3F%5C.)%2B%5Ba-zA-Z%5D%7B2%2C6%7D(%5C%2F)"></iframe><h3 id="4、账号"><a href="#4、账号" class="headerlink" title="4、账号"></a>4、账号</h3><p>字母开头，允许4-16字节，允许字母数字下划线<br><code>^[a-zA-Z][a-zA-Z0-9_]&#123;3,15&#125;$</code></p><iframe frameborder="0" width="100%" height="260" src="https://jex.im/regulex/#!embed=true&flags=&re=%5E%5Ba-zA-Z%5D%5Ba-zA-Z0-9_%5D%7B3%2C15%7D%24"></iframe><h3 id="5、IP地址"><a href="#5、IP地址" class="headerlink" title="5、IP地址"></a>5、IP地址</h3><p><code>((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</code></p><iframe frameborder="0" width="100%" height="370" src="https://jex.im/regulex/#!embed=true&flags=&re=((%3F%3A(%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C%5B01%5D%3F%5Cd%3F%5Cd)%5C.)%7B3%7D(%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C%5B01%5D%3F%5Cd%3F%5Cd))"></iframe>]]></content>
    
    
    <categories>
      
      <category>实用总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序表相关习题(C语言实现)</title>
    <link href="/2019/sequence-list/"/>
    <url>/2019/sequence-list/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h1><p>线性表的顺序存储又称为顺序表。它是一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的元素在物理上也相邻。<br><a id="more"></a><br>假定线性表的元素类型是ElemType，线性表的顺序存储类型描述为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 100 <span class="hljs-comment">//表长初始值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType; <span class="hljs-comment">//顺序表元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>ElemType data[MaxSize];<span class="hljs-comment">//表中数据元素</span><br><span class="hljs-keyword">int</span> Length;<span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><h1 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h1><h2 id="1、删除具有最小值的元素"><a href="#1、删除具有最小值的元素" class="headerlink" title="1、删除具有最小值的元素"></a>1、删除具有最小值的元素</h2><p>从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。</p><blockquote><p>思路：遍历顺序表找到最小元素，记录其位置，然后将其替换为最后一个元素。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">(SqList &amp;L, ElemType &amp;left)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (L.Length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    left = L.data[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-comment">//最小值位置记录</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] &lt; left)&#123;<br>           left = L.data[i];<br>           pos = i;<br>        &#125;<br>    &#125;<br>    L.data[pos] = L.data[L.Length<span class="hljs-number">-1</span>];<br>    L.Length--;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、元素逆置"><a href="#2、元素逆置" class="headerlink" title="2、元素逆置"></a>2、元素逆置</h2><p>设计一个高效的算法，将顺序表的所有元素逆置，要求算法的空间复杂度为O(1)。</p><blockquote><p>思路：将第i个元素和第n-i个元素互换。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (L.Length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> n = L.Length/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> tmp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;n; i++)&#123;<br>        <span class="hljs-keyword">int</span> j = L.Length<span class="hljs-number">-1</span>-i;<br>        tmp = L.data[i];<br>        L.data[i] = L.data[j];<br>        L.data[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、删除所有值为X的数据元素"><a href="#3、删除所有值为X的数据元素" class="headerlink" title="3、删除所有值为X的数据元素"></a>3、删除所有值为X的数据元素</h2><p>长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除该线性表中所有值为x的数据元素。</p><blockquote><p>思路：遍历顺序表时记录值不为x的个数j，并将第i个元素移动至第j个。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValue</span><span class="hljs-params">(SqList &amp;L,ElemType value)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] != value)&#123;<br>            L.data[j] = L.data[i];<br>            j++;<br>        &#125;<br>    &#125;<br>    L.Length = j;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、有序表中删除值在给定区间的数据元素"><a href="#4、有序表中删除值在给定区间的数据元素" class="headerlink" title="4、有序表中删除值在给定区间的数据元素"></a>4、有序表中删除值在给定区间的数据元素</h2><p>从有序顺序表中删除其值在给定值s与t之间（要求s&lt;t）的所有元素，如果s或t不合理或者顺序表为空则显示出错信息并退出。</p><blockquote><p>解法1：遍历顺序表，元素值小于等于s时无操作；元素值在s与t之间时计数n加一，元素值大于等于t时元素前移n位。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValueBetweenST</span><span class="hljs-params">(SqList &amp;L, ElemType s, ElemType t)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(s &gt;= t || L.Length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] &gt; s &amp;&amp; L.data[i] &lt; t )&#123;<br>            n++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L.data[i] &gt;= t)&#123;<br>            L.data[i-n] = L.data[i];<br>        &#125;<br>    &#125;<br>    L.Length -= n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解法2：与题目3类似，判断条件变为元素值不在s与t之间。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValueBetweenST</span><span class="hljs-params">(SqList &amp;L, ElemType s, ElemType t)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(s &gt;= t || L.Length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] &lt;= s || L.data[i]&gt;= t )&#123;<br>            L.data[j] = L.data[i];<br>            j++;<br>        &#125;<br>    &#125;<br>    L.Length = j;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、无序表中删除值在给定区间的数据元素"><a href="#5、无序表中删除值在给定区间的数据元素" class="headerlink" title="5、无序表中删除值在给定区间的数据元素"></a>5、无序表中删除值在给定区间的数据元素</h2><p>从顺序表中删除其值在给定值s与t之间（包含s和t，要求s&lt;t）的所有元素，如果s或t不合理或者顺序表为空则显示出错信息并退出。</p><blockquote><p>思路：与题目3类似，判断条件变为元素值小于s或者大于t。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteValueBetweenST2</span><span class="hljs-params">(SqList &amp;L, ElemType s, ElemType t)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(s &gt;= t || L.Length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.Length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] &lt; s || L.data[i]&gt; t )&#123;<br>            L.data[j] = L.data[i];<br>            j++;<br>        &#125;<br>    &#125;<br>    L.Length = j;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、删除重复的的数据元素"><a href="#6、删除重复的的数据元素" class="headerlink" title="6、删除重复的的数据元素"></a>6、删除重复的的数据元素</h2><p>从有序顺序表中删除所有其值重复的元素。使表中所有元素值均不同。</p><blockquote><p>思路：遍历顺序表，依次判断当前元素与下一元素是否相同。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteSameValue</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(L.Length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; L.Length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (L.data[j] != L.data[i])&#123;<br>            L.data[j+<span class="hljs-number">1</span>] = L.data[i];<br>            j++;<br>        &#125;<br>    &#125;<br>    L.Length = j + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、合并顺序表"><a href="#7、合并顺序表" class="headerlink" title="7、合并顺序表"></a>7、合并顺序表</h2><p>将两个有序顺序表合并成一个新的有序顺序表，并由函数返回结果顺序表</p><blockquote><p>思路：比较两个有序顺序表A与B的最小的元素，将最小元素放入顺序表L中。重复此操作。最后将A或者B中剩余未比较部分加入到表L。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(SqList &amp;L, SqList A, SqList B)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>,k = <span class="hljs-number">0</span>;<span class="hljs-comment">//分别标记三个数组下标</span><br>    <span class="hljs-keyword">for</span> (; i &lt; A.Length || j &lt; B.Length; )&#123; <span class="hljs-comment">//比较大小，将较小的值放入顺序表L</span><br>        <span class="hljs-keyword">if</span>(A.data[i] &gt;= B.data[j])&#123;<br>            L.data[k++] = B.data[j++];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A.data[i] &lt; B.data[j])&#123;<br>            L.data[k++] = A.data[i++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>( i &lt; A.Length)&#123;<span class="hljs-comment">//将比较完毕后剩余的元素加入表L</span><br>        L.data[k++] = A.data[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>( j &lt; B.Length)&#123;<br>        L.data[k++] = B.data[j++];<br>    &#125;<br>    L.Length = k;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、顺序表位置互换"><a href="#8、顺序表位置互换" class="headerlink" title="8、顺序表位置互换"></a>8、顺序表位置互换</h2><p>已知在一维数组A[m+n]中依次存放着两个线性表（$a_1,a_2,…,a_m$)与($b_1,b_2,…,b_n$)。试编写一个函数，将数组中两个顺序表的位置互换。</p><blockquote><p>思路：先整体逆置，再分别逆置0到n-1和n到n+m-1。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reverse</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-comment">//将顺序表的left到right逆置</span><br>    <span class="hljs-keyword">if</span> (L.Length == <span class="hljs-number">0</span> || left &gt; right || right &gt;= L.Length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> n = (right + left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> tmp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-left; i++)&#123;<br>        tmp = L.data[left+i];<br>        L.data[left+i] = L.data[right-i];<br>        L.data[right-i] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    reverse(L, <span class="hljs-number">0</span>, m + n<span class="hljs-number">-1</span>);<br>    reverse(L, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    reverse(L, n, m + n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9、查找值为x的元素并与后继元素交换位置"><a href="#9、查找值为x的元素并与后继元素交换位置" class="headerlink" title="9、查找值为x的元素并与后继元素交换位置"></a>9、查找值为x的元素并与后继元素交换位置</h2><p>线性表（$a_1,a_2,…,a_m$)中元素递增有序且按照顺序存储于计算机中。要求设计一算法完成用最少时间在表中查找数值为x的元素，若找到将其与后继元素位置相交换，若找不到将其插入表中并使表中元素仍然有序。</p><blockquote><p>思路：查找时间最少，使用折半查找法。有值为x的函数则与下一元素交换位置，没有则将值大于x的元素后移一位，插入x。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchValue</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> low, mid ,high;<span class="hljs-comment">//折半查找</span><br>    low = <span class="hljs-number">0</span>;<br>    high = L.Length<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        mid = (low + high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(L.data[mid] &gt; x)&#123;<br>            high = mid<span class="hljs-number">-1</span>; <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.data[mid] &lt; x)&#123;<br>            low = mid+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low &gt; high)&#123;<span class="hljs-comment">//无该元素则插入</span><br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = L.Length<span class="hljs-number">-1</span>;L.data[i] &gt; x; i--)&#123; <span class="hljs-comment">//大于x的元素后移一位</span><br>            L.data[i+<span class="hljs-number">1</span>] = L.data[i];<br>        &#125;<br>        L.data[i+<span class="hljs-number">1</span>] = x;<span class="hljs-comment">//插入x</span><br>        L.Length++;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//有该元素则与下一元素交换</span><br>        <span class="hljs-keyword">int</span> tmp = L.data[mid];<br>        L.data[mid] = L.data[mid+<span class="hljs-number">1</span>];<br>        L.data[mid+<span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C语言</tag>
      
      <tag>顺序表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
